/* PyHTML Client core v0.0.1 - https://github.com/reecelikesramen/pyhtml */
"use strict";
var PyHTMLCore = (() => {
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __export = (target, all) => {
    for (var name in all)
      __defProp(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
  var __publicField = (obj, key, value) => {
    __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
    return value;
  };

  // src/pyhtml.core.ts
  var pyhtml_core_exports = {};
  __export(pyhtml_core_exports, {
    DOMUpdater: () => DOMUpdater,
    HTTPTransport: () => HTTPTransport,
    PyHTMLApp: () => PyHTMLApp,
    TransportManager: () => TransportManager,
    WebSocketTransport: () => WebSocketTransport,
    WebTransportTransport: () => WebTransportTransport,
    app: () => app
  });

  // src/core/transports/base.ts
  var BaseTransport = class {
    constructor() {
      this.messageHandlers = [];
      this.statusHandlers = [];
      this.connected = false;
    }
    onMessage(handler) {
      this.messageHandlers.push(handler);
    }
    onStatusChange(handler) {
      this.statusHandlers.push(handler);
    }
    isConnected() {
      return this.connected;
    }
    notifyHandlers(message) {
      for (const handler of this.messageHandlers) {
        try {
          handler(message);
        } catch (e) {
          console.error("PyHTML: Error in message handler", e);
        }
      }
    }
    notifyStatus(connected) {
      if (this.connected === connected)
        return;
      this.connected = connected;
      for (const handler of this.statusHandlers) {
        try {
          handler(connected);
        } catch (e) {
          console.error("PyHTML: Error in status handler", e);
        }
      }
    }
  };

  // src/core/transports/webtransport.ts
  var WebTransportTransport = class _WebTransportTransport extends BaseTransport {
    constructor(url) {
      super();
      this.name = "WebTransport";
      this.transport = null;
      this.writer = null;
      this.encoder = new TextEncoder();
      this.decoder = new TextDecoder();
      this.url = url || this.getDefaultUrl();
    }
    getDefaultUrl() {
      return `https://${window.location.host}/_pyhtml/webtransport`;
    }
    /**
     * Check if WebTransport is available in this browser.
     */
    static isSupported() {
      return typeof WebTransport !== "undefined";
    }
    async connect() {
      if (!_WebTransportTransport.isSupported()) {
        throw new Error("WebTransport not supported in this browser");
      }
      try {
        const options = {};
        const certHash = window.PYHTML_CERT_HASH;
        if (certHash && Array.isArray(certHash)) {
          options.serverCertificateHashes = [{
            algorithm: "sha-256",
            value: new Uint8Array(certHash)
          }];
          console.log("PyHTML: Using explicit certificate hash for WebTransport");
        }
        this.transport = new WebTransport(this.url, options);
        await this.transport.ready;
        console.log("PyHTML: WebTransport ready");
        this.connected = true;
        this.startReading();
      } catch (e) {
        this.handleDisconnect();
        throw e;
      }
    }
    async startReading() {
      if (!this.transport)
        return;
      const reader = this.transport.incomingBidirectionalStreams.getReader();
      try {
        while (true) {
          const { value: stream, done } = await reader.read();
          if (done)
            break;
          this.handleStream(stream);
        }
      } catch (e) {
        if (this.connected) {
          console.error("PyHTML: WebTransport read error", e);
          this.handleDisconnect();
        }
      }
    }
    async handleStream(stream) {
      const reader = stream.readable.getReader();
      try {
        while (true) {
          const { value, done } = await reader.read();
          if (done)
            break;
          if (value) {
            const text = this.decoder.decode(value);
            try {
              const msg = JSON.parse(text);
              this.notifyHandlers(msg);
            } catch (e) {
              console.error("PyHTML: Error parsing WebTransport message", e);
            }
          }
        }
      } catch (e) {
        console.error("PyHTML: Stream read error", e);
      }
    }
    async send(message) {
      if (!this.transport || !this.connected) {
        console.warn("PyHTML: Cannot send message, WebTransport not connected");
        return;
      }
      try {
        const stream = await this.transport.createBidirectionalStream();
        const writer = stream.writable.getWriter();
        const data = this.encoder.encode(JSON.stringify(message));
        await writer.write(data);
        await writer.close();
        this.handleStream(stream);
      } catch (e) {
        console.error("PyHTML: WebTransport send error", e);
      }
    }
    disconnect() {
      if (this.transport) {
        this.transport.close();
        this.transport = null;
      }
      this.writer = null;
      this.connected = false;
    }
    handleDisconnect() {
      this.connected = false;
      this.transport = null;
      this.writer = null;
    }
  };

  // node_modules/.pnpm/@msgpack+msgpack@3.1.3/node_modules/@msgpack/msgpack/dist.esm/utils/utf8.mjs
  function utf8Count(str) {
    const strLength = str.length;
    let byteLength = 0;
    let pos = 0;
    while (pos < strLength) {
      let value = str.charCodeAt(pos++);
      if ((value & 4294967168) === 0) {
        byteLength++;
        continue;
      } else if ((value & 4294965248) === 0) {
        byteLength += 2;
      } else {
        if (value >= 55296 && value <= 56319) {
          if (pos < strLength) {
            const extra = str.charCodeAt(pos);
            if ((extra & 64512) === 56320) {
              ++pos;
              value = ((value & 1023) << 10) + (extra & 1023) + 65536;
            }
          }
        }
        if ((value & 4294901760) === 0) {
          byteLength += 3;
        } else {
          byteLength += 4;
        }
      }
    }
    return byteLength;
  }
  function utf8EncodeJs(str, output, outputOffset) {
    const strLength = str.length;
    let offset = outputOffset;
    let pos = 0;
    while (pos < strLength) {
      let value = str.charCodeAt(pos++);
      if ((value & 4294967168) === 0) {
        output[offset++] = value;
        continue;
      } else if ((value & 4294965248) === 0) {
        output[offset++] = value >> 6 & 31 | 192;
      } else {
        if (value >= 55296 && value <= 56319) {
          if (pos < strLength) {
            const extra = str.charCodeAt(pos);
            if ((extra & 64512) === 56320) {
              ++pos;
              value = ((value & 1023) << 10) + (extra & 1023) + 65536;
            }
          }
        }
        if ((value & 4294901760) === 0) {
          output[offset++] = value >> 12 & 15 | 224;
          output[offset++] = value >> 6 & 63 | 128;
        } else {
          output[offset++] = value >> 18 & 7 | 240;
          output[offset++] = value >> 12 & 63 | 128;
          output[offset++] = value >> 6 & 63 | 128;
        }
      }
      output[offset++] = value & 63 | 128;
    }
  }
  var sharedTextEncoder = new TextEncoder();
  var TEXT_ENCODER_THRESHOLD = 50;
  function utf8EncodeTE(str, output, outputOffset) {
    sharedTextEncoder.encodeInto(str, output.subarray(outputOffset));
  }
  function utf8Encode(str, output, outputOffset) {
    if (str.length > TEXT_ENCODER_THRESHOLD) {
      utf8EncodeTE(str, output, outputOffset);
    } else {
      utf8EncodeJs(str, output, outputOffset);
    }
  }
  var CHUNK_SIZE = 4096;
  function utf8DecodeJs(bytes, inputOffset, byteLength) {
    let offset = inputOffset;
    const end = offset + byteLength;
    const units = [];
    let result = "";
    while (offset < end) {
      const byte1 = bytes[offset++];
      if ((byte1 & 128) === 0) {
        units.push(byte1);
      } else if ((byte1 & 224) === 192) {
        const byte2 = bytes[offset++] & 63;
        units.push((byte1 & 31) << 6 | byte2);
      } else if ((byte1 & 240) === 224) {
        const byte2 = bytes[offset++] & 63;
        const byte3 = bytes[offset++] & 63;
        units.push((byte1 & 31) << 12 | byte2 << 6 | byte3);
      } else if ((byte1 & 248) === 240) {
        const byte2 = bytes[offset++] & 63;
        const byte3 = bytes[offset++] & 63;
        const byte4 = bytes[offset++] & 63;
        let unit = (byte1 & 7) << 18 | byte2 << 12 | byte3 << 6 | byte4;
        if (unit > 65535) {
          unit -= 65536;
          units.push(unit >>> 10 & 1023 | 55296);
          unit = 56320 | unit & 1023;
        }
        units.push(unit);
      } else {
        units.push(byte1);
      }
      if (units.length >= CHUNK_SIZE) {
        result += String.fromCharCode(...units);
        units.length = 0;
      }
    }
    if (units.length > 0) {
      result += String.fromCharCode(...units);
    }
    return result;
  }
  var sharedTextDecoder = new TextDecoder();
  var TEXT_DECODER_THRESHOLD = 200;
  function utf8DecodeTD(bytes, inputOffset, byteLength) {
    const stringBytes = bytes.subarray(inputOffset, inputOffset + byteLength);
    return sharedTextDecoder.decode(stringBytes);
  }
  function utf8Decode(bytes, inputOffset, byteLength) {
    if (byteLength > TEXT_DECODER_THRESHOLD) {
      return utf8DecodeTD(bytes, inputOffset, byteLength);
    } else {
      return utf8DecodeJs(bytes, inputOffset, byteLength);
    }
  }

  // node_modules/.pnpm/@msgpack+msgpack@3.1.3/node_modules/@msgpack/msgpack/dist.esm/ExtData.mjs
  var ExtData = class {
    constructor(type, data) {
      __publicField(this, "type");
      __publicField(this, "data");
      this.type = type;
      this.data = data;
    }
  };

  // node_modules/.pnpm/@msgpack+msgpack@3.1.3/node_modules/@msgpack/msgpack/dist.esm/DecodeError.mjs
  var DecodeError = class _DecodeError extends Error {
    constructor(message) {
      super(message);
      const proto = Object.create(_DecodeError.prototype);
      Object.setPrototypeOf(this, proto);
      Object.defineProperty(this, "name", {
        configurable: true,
        enumerable: false,
        value: _DecodeError.name
      });
    }
  };

  // node_modules/.pnpm/@msgpack+msgpack@3.1.3/node_modules/@msgpack/msgpack/dist.esm/utils/int.mjs
  var UINT32_MAX = 4294967295;
  function setUint64(view, offset, value) {
    const high = value / 4294967296;
    const low = value;
    view.setUint32(offset, high);
    view.setUint32(offset + 4, low);
  }
  function setInt64(view, offset, value) {
    const high = Math.floor(value / 4294967296);
    const low = value;
    view.setUint32(offset, high);
    view.setUint32(offset + 4, low);
  }
  function getInt64(view, offset) {
    const high = view.getInt32(offset);
    const low = view.getUint32(offset + 4);
    return high * 4294967296 + low;
  }
  function getUint64(view, offset) {
    const high = view.getUint32(offset);
    const low = view.getUint32(offset + 4);
    return high * 4294967296 + low;
  }

  // node_modules/.pnpm/@msgpack+msgpack@3.1.3/node_modules/@msgpack/msgpack/dist.esm/timestamp.mjs
  var EXT_TIMESTAMP = -1;
  var TIMESTAMP32_MAX_SEC = 4294967296 - 1;
  var TIMESTAMP64_MAX_SEC = 17179869184 - 1;
  function encodeTimeSpecToTimestamp({ sec, nsec }) {
    if (sec >= 0 && nsec >= 0 && sec <= TIMESTAMP64_MAX_SEC) {
      if (nsec === 0 && sec <= TIMESTAMP32_MAX_SEC) {
        const rv = new Uint8Array(4);
        const view = new DataView(rv.buffer);
        view.setUint32(0, sec);
        return rv;
      } else {
        const secHigh = sec / 4294967296;
        const secLow = sec & 4294967295;
        const rv = new Uint8Array(8);
        const view = new DataView(rv.buffer);
        view.setUint32(0, nsec << 2 | secHigh & 3);
        view.setUint32(4, secLow);
        return rv;
      }
    } else {
      const rv = new Uint8Array(12);
      const view = new DataView(rv.buffer);
      view.setUint32(0, nsec);
      setInt64(view, 4, sec);
      return rv;
    }
  }
  function encodeDateToTimeSpec(date) {
    const msec = date.getTime();
    const sec = Math.floor(msec / 1e3);
    const nsec = (msec - sec * 1e3) * 1e6;
    const nsecInSec = Math.floor(nsec / 1e9);
    return {
      sec: sec + nsecInSec,
      nsec: nsec - nsecInSec * 1e9
    };
  }
  function encodeTimestampExtension(object) {
    if (object instanceof Date) {
      const timeSpec = encodeDateToTimeSpec(object);
      return encodeTimeSpecToTimestamp(timeSpec);
    } else {
      return null;
    }
  }
  function decodeTimestampToTimeSpec(data) {
    const view = new DataView(data.buffer, data.byteOffset, data.byteLength);
    switch (data.byteLength) {
      case 4: {
        const sec = view.getUint32(0);
        const nsec = 0;
        return { sec, nsec };
      }
      case 8: {
        const nsec30AndSecHigh2 = view.getUint32(0);
        const secLow32 = view.getUint32(4);
        const sec = (nsec30AndSecHigh2 & 3) * 4294967296 + secLow32;
        const nsec = nsec30AndSecHigh2 >>> 2;
        return { sec, nsec };
      }
      case 12: {
        const sec = getInt64(view, 4);
        const nsec = view.getUint32(0);
        return { sec, nsec };
      }
      default:
        throw new DecodeError(`Unrecognized data size for timestamp (expected 4, 8, or 12): ${data.length}`);
    }
  }
  function decodeTimestampExtension(data) {
    const timeSpec = decodeTimestampToTimeSpec(data);
    return new Date(timeSpec.sec * 1e3 + timeSpec.nsec / 1e6);
  }
  var timestampExtension = {
    type: EXT_TIMESTAMP,
    encode: encodeTimestampExtension,
    decode: decodeTimestampExtension
  };

  // node_modules/.pnpm/@msgpack+msgpack@3.1.3/node_modules/@msgpack/msgpack/dist.esm/ExtensionCodec.mjs
  var _ExtensionCodec = class _ExtensionCodec {
    constructor() {
      // ensures ExtensionCodecType<X> matches ExtensionCodec<X>
      // this will make type errors a lot more clear
      // eslint-disable-next-line @typescript-eslint/naming-convention
      __publicField(this, "__brand");
      // built-in extensions
      __publicField(this, "builtInEncoders", []);
      __publicField(this, "builtInDecoders", []);
      // custom extensions
      __publicField(this, "encoders", []);
      __publicField(this, "decoders", []);
      this.register(timestampExtension);
    }
    register({ type, encode: encode2, decode: decode2 }) {
      if (type >= 0) {
        this.encoders[type] = encode2;
        this.decoders[type] = decode2;
      } else {
        const index = -1 - type;
        this.builtInEncoders[index] = encode2;
        this.builtInDecoders[index] = decode2;
      }
    }
    tryToEncode(object, context) {
      for (let i = 0; i < this.builtInEncoders.length; i++) {
        const encodeExt = this.builtInEncoders[i];
        if (encodeExt != null) {
          const data = encodeExt(object, context);
          if (data != null) {
            const type = -1 - i;
            return new ExtData(type, data);
          }
        }
      }
      for (let i = 0; i < this.encoders.length; i++) {
        const encodeExt = this.encoders[i];
        if (encodeExt != null) {
          const data = encodeExt(object, context);
          if (data != null) {
            const type = i;
            return new ExtData(type, data);
          }
        }
      }
      if (object instanceof ExtData) {
        return object;
      }
      return null;
    }
    decode(data, type, context) {
      const decodeExt = type < 0 ? this.builtInDecoders[-1 - type] : this.decoders[type];
      if (decodeExt) {
        return decodeExt(data, type, context);
      } else {
        return new ExtData(type, data);
      }
    }
  };
  __publicField(_ExtensionCodec, "defaultCodec", new _ExtensionCodec());
  var ExtensionCodec = _ExtensionCodec;

  // node_modules/.pnpm/@msgpack+msgpack@3.1.3/node_modules/@msgpack/msgpack/dist.esm/utils/typedArrays.mjs
  function isArrayBufferLike(buffer) {
    return buffer instanceof ArrayBuffer || typeof SharedArrayBuffer !== "undefined" && buffer instanceof SharedArrayBuffer;
  }
  function ensureUint8Array(buffer) {
    if (buffer instanceof Uint8Array) {
      return buffer;
    } else if (ArrayBuffer.isView(buffer)) {
      return new Uint8Array(buffer.buffer, buffer.byteOffset, buffer.byteLength);
    } else if (isArrayBufferLike(buffer)) {
      return new Uint8Array(buffer);
    } else {
      return Uint8Array.from(buffer);
    }
  }

  // node_modules/.pnpm/@msgpack+msgpack@3.1.3/node_modules/@msgpack/msgpack/dist.esm/Encoder.mjs
  var DEFAULT_MAX_DEPTH = 100;
  var DEFAULT_INITIAL_BUFFER_SIZE = 2048;
  var Encoder = class _Encoder {
    constructor(options) {
      __publicField(this, "extensionCodec");
      __publicField(this, "context");
      __publicField(this, "useBigInt64");
      __publicField(this, "maxDepth");
      __publicField(this, "initialBufferSize");
      __publicField(this, "sortKeys");
      __publicField(this, "forceFloat32");
      __publicField(this, "ignoreUndefined");
      __publicField(this, "forceIntegerToFloat");
      __publicField(this, "pos");
      __publicField(this, "view");
      __publicField(this, "bytes");
      __publicField(this, "entered", false);
      this.extensionCodec = options?.extensionCodec ?? ExtensionCodec.defaultCodec;
      this.context = options?.context;
      this.useBigInt64 = options?.useBigInt64 ?? false;
      this.maxDepth = options?.maxDepth ?? DEFAULT_MAX_DEPTH;
      this.initialBufferSize = options?.initialBufferSize ?? DEFAULT_INITIAL_BUFFER_SIZE;
      this.sortKeys = options?.sortKeys ?? false;
      this.forceFloat32 = options?.forceFloat32 ?? false;
      this.ignoreUndefined = options?.ignoreUndefined ?? false;
      this.forceIntegerToFloat = options?.forceIntegerToFloat ?? false;
      this.pos = 0;
      this.view = new DataView(new ArrayBuffer(this.initialBufferSize));
      this.bytes = new Uint8Array(this.view.buffer);
    }
    clone() {
      return new _Encoder({
        extensionCodec: this.extensionCodec,
        context: this.context,
        useBigInt64: this.useBigInt64,
        maxDepth: this.maxDepth,
        initialBufferSize: this.initialBufferSize,
        sortKeys: this.sortKeys,
        forceFloat32: this.forceFloat32,
        ignoreUndefined: this.ignoreUndefined,
        forceIntegerToFloat: this.forceIntegerToFloat
      });
    }
    reinitializeState() {
      this.pos = 0;
    }
    /**
     * This is almost equivalent to {@link Encoder#encode}, but it returns an reference of the encoder's internal buffer and thus much faster than {@link Encoder#encode}.
     *
     * @returns Encodes the object and returns a shared reference the encoder's internal buffer.
     */
    encodeSharedRef(object) {
      if (this.entered) {
        const instance = this.clone();
        return instance.encodeSharedRef(object);
      }
      try {
        this.entered = true;
        this.reinitializeState();
        this.doEncode(object, 1);
        return this.bytes.subarray(0, this.pos);
      } finally {
        this.entered = false;
      }
    }
    /**
     * @returns Encodes the object and returns a copy of the encoder's internal buffer.
     */
    encode(object) {
      if (this.entered) {
        const instance = this.clone();
        return instance.encode(object);
      }
      try {
        this.entered = true;
        this.reinitializeState();
        this.doEncode(object, 1);
        return this.bytes.slice(0, this.pos);
      } finally {
        this.entered = false;
      }
    }
    doEncode(object, depth) {
      if (depth > this.maxDepth) {
        throw new Error(`Too deep objects in depth ${depth}`);
      }
      if (object == null) {
        this.encodeNil();
      } else if (typeof object === "boolean") {
        this.encodeBoolean(object);
      } else if (typeof object === "number") {
        if (!this.forceIntegerToFloat) {
          this.encodeNumber(object);
        } else {
          this.encodeNumberAsFloat(object);
        }
      } else if (typeof object === "string") {
        this.encodeString(object);
      } else if (this.useBigInt64 && typeof object === "bigint") {
        this.encodeBigInt64(object);
      } else {
        this.encodeObject(object, depth);
      }
    }
    ensureBufferSizeToWrite(sizeToWrite) {
      const requiredSize = this.pos + sizeToWrite;
      if (this.view.byteLength < requiredSize) {
        this.resizeBuffer(requiredSize * 2);
      }
    }
    resizeBuffer(newSize) {
      const newBuffer = new ArrayBuffer(newSize);
      const newBytes = new Uint8Array(newBuffer);
      const newView = new DataView(newBuffer);
      newBytes.set(this.bytes);
      this.view = newView;
      this.bytes = newBytes;
    }
    encodeNil() {
      this.writeU8(192);
    }
    encodeBoolean(object) {
      if (object === false) {
        this.writeU8(194);
      } else {
        this.writeU8(195);
      }
    }
    encodeNumber(object) {
      if (!this.forceIntegerToFloat && Number.isSafeInteger(object)) {
        if (object >= 0) {
          if (object < 128) {
            this.writeU8(object);
          } else if (object < 256) {
            this.writeU8(204);
            this.writeU8(object);
          } else if (object < 65536) {
            this.writeU8(205);
            this.writeU16(object);
          } else if (object < 4294967296) {
            this.writeU8(206);
            this.writeU32(object);
          } else if (!this.useBigInt64) {
            this.writeU8(207);
            this.writeU64(object);
          } else {
            this.encodeNumberAsFloat(object);
          }
        } else {
          if (object >= -32) {
            this.writeU8(224 | object + 32);
          } else if (object >= -128) {
            this.writeU8(208);
            this.writeI8(object);
          } else if (object >= -32768) {
            this.writeU8(209);
            this.writeI16(object);
          } else if (object >= -2147483648) {
            this.writeU8(210);
            this.writeI32(object);
          } else if (!this.useBigInt64) {
            this.writeU8(211);
            this.writeI64(object);
          } else {
            this.encodeNumberAsFloat(object);
          }
        }
      } else {
        this.encodeNumberAsFloat(object);
      }
    }
    encodeNumberAsFloat(object) {
      if (this.forceFloat32) {
        this.writeU8(202);
        this.writeF32(object);
      } else {
        this.writeU8(203);
        this.writeF64(object);
      }
    }
    encodeBigInt64(object) {
      if (object >= BigInt(0)) {
        this.writeU8(207);
        this.writeBigUint64(object);
      } else {
        this.writeU8(211);
        this.writeBigInt64(object);
      }
    }
    writeStringHeader(byteLength) {
      if (byteLength < 32) {
        this.writeU8(160 + byteLength);
      } else if (byteLength < 256) {
        this.writeU8(217);
        this.writeU8(byteLength);
      } else if (byteLength < 65536) {
        this.writeU8(218);
        this.writeU16(byteLength);
      } else if (byteLength < 4294967296) {
        this.writeU8(219);
        this.writeU32(byteLength);
      } else {
        throw new Error(`Too long string: ${byteLength} bytes in UTF-8`);
      }
    }
    encodeString(object) {
      const maxHeaderSize = 1 + 4;
      const byteLength = utf8Count(object);
      this.ensureBufferSizeToWrite(maxHeaderSize + byteLength);
      this.writeStringHeader(byteLength);
      utf8Encode(object, this.bytes, this.pos);
      this.pos += byteLength;
    }
    encodeObject(object, depth) {
      const ext = this.extensionCodec.tryToEncode(object, this.context);
      if (ext != null) {
        this.encodeExtension(ext);
      } else if (Array.isArray(object)) {
        this.encodeArray(object, depth);
      } else if (ArrayBuffer.isView(object)) {
        this.encodeBinary(object);
      } else if (typeof object === "object") {
        this.encodeMap(object, depth);
      } else {
        throw new Error(`Unrecognized object: ${Object.prototype.toString.apply(object)}`);
      }
    }
    encodeBinary(object) {
      const size = object.byteLength;
      if (size < 256) {
        this.writeU8(196);
        this.writeU8(size);
      } else if (size < 65536) {
        this.writeU8(197);
        this.writeU16(size);
      } else if (size < 4294967296) {
        this.writeU8(198);
        this.writeU32(size);
      } else {
        throw new Error(`Too large binary: ${size}`);
      }
      const bytes = ensureUint8Array(object);
      this.writeU8a(bytes);
    }
    encodeArray(object, depth) {
      const size = object.length;
      if (size < 16) {
        this.writeU8(144 + size);
      } else if (size < 65536) {
        this.writeU8(220);
        this.writeU16(size);
      } else if (size < 4294967296) {
        this.writeU8(221);
        this.writeU32(size);
      } else {
        throw new Error(`Too large array: ${size}`);
      }
      for (const item of object) {
        this.doEncode(item, depth + 1);
      }
    }
    countWithoutUndefined(object, keys) {
      let count = 0;
      for (const key of keys) {
        if (object[key] !== void 0) {
          count++;
        }
      }
      return count;
    }
    encodeMap(object, depth) {
      const keys = Object.keys(object);
      if (this.sortKeys) {
        keys.sort();
      }
      const size = this.ignoreUndefined ? this.countWithoutUndefined(object, keys) : keys.length;
      if (size < 16) {
        this.writeU8(128 + size);
      } else if (size < 65536) {
        this.writeU8(222);
        this.writeU16(size);
      } else if (size < 4294967296) {
        this.writeU8(223);
        this.writeU32(size);
      } else {
        throw new Error(`Too large map object: ${size}`);
      }
      for (const key of keys) {
        const value = object[key];
        if (!(this.ignoreUndefined && value === void 0)) {
          this.encodeString(key);
          this.doEncode(value, depth + 1);
        }
      }
    }
    encodeExtension(ext) {
      if (typeof ext.data === "function") {
        const data = ext.data(this.pos + 6);
        const size2 = data.length;
        if (size2 >= 4294967296) {
          throw new Error(`Too large extension object: ${size2}`);
        }
        this.writeU8(201);
        this.writeU32(size2);
        this.writeI8(ext.type);
        this.writeU8a(data);
        return;
      }
      const size = ext.data.length;
      if (size === 1) {
        this.writeU8(212);
      } else if (size === 2) {
        this.writeU8(213);
      } else if (size === 4) {
        this.writeU8(214);
      } else if (size === 8) {
        this.writeU8(215);
      } else if (size === 16) {
        this.writeU8(216);
      } else if (size < 256) {
        this.writeU8(199);
        this.writeU8(size);
      } else if (size < 65536) {
        this.writeU8(200);
        this.writeU16(size);
      } else if (size < 4294967296) {
        this.writeU8(201);
        this.writeU32(size);
      } else {
        throw new Error(`Too large extension object: ${size}`);
      }
      this.writeI8(ext.type);
      this.writeU8a(ext.data);
    }
    writeU8(value) {
      this.ensureBufferSizeToWrite(1);
      this.view.setUint8(this.pos, value);
      this.pos++;
    }
    writeU8a(values) {
      const size = values.length;
      this.ensureBufferSizeToWrite(size);
      this.bytes.set(values, this.pos);
      this.pos += size;
    }
    writeI8(value) {
      this.ensureBufferSizeToWrite(1);
      this.view.setInt8(this.pos, value);
      this.pos++;
    }
    writeU16(value) {
      this.ensureBufferSizeToWrite(2);
      this.view.setUint16(this.pos, value);
      this.pos += 2;
    }
    writeI16(value) {
      this.ensureBufferSizeToWrite(2);
      this.view.setInt16(this.pos, value);
      this.pos += 2;
    }
    writeU32(value) {
      this.ensureBufferSizeToWrite(4);
      this.view.setUint32(this.pos, value);
      this.pos += 4;
    }
    writeI32(value) {
      this.ensureBufferSizeToWrite(4);
      this.view.setInt32(this.pos, value);
      this.pos += 4;
    }
    writeF32(value) {
      this.ensureBufferSizeToWrite(4);
      this.view.setFloat32(this.pos, value);
      this.pos += 4;
    }
    writeF64(value) {
      this.ensureBufferSizeToWrite(8);
      this.view.setFloat64(this.pos, value);
      this.pos += 8;
    }
    writeU64(value) {
      this.ensureBufferSizeToWrite(8);
      setUint64(this.view, this.pos, value);
      this.pos += 8;
    }
    writeI64(value) {
      this.ensureBufferSizeToWrite(8);
      setInt64(this.view, this.pos, value);
      this.pos += 8;
    }
    writeBigUint64(value) {
      this.ensureBufferSizeToWrite(8);
      this.view.setBigUint64(this.pos, value);
      this.pos += 8;
    }
    writeBigInt64(value) {
      this.ensureBufferSizeToWrite(8);
      this.view.setBigInt64(this.pos, value);
      this.pos += 8;
    }
  };

  // node_modules/.pnpm/@msgpack+msgpack@3.1.3/node_modules/@msgpack/msgpack/dist.esm/encode.mjs
  function encode(value, options) {
    const encoder = new Encoder(options);
    return encoder.encodeSharedRef(value);
  }

  // node_modules/.pnpm/@msgpack+msgpack@3.1.3/node_modules/@msgpack/msgpack/dist.esm/utils/prettyByte.mjs
  function prettyByte(byte) {
    return `${byte < 0 ? "-" : ""}0x${Math.abs(byte).toString(16).padStart(2, "0")}`;
  }

  // node_modules/.pnpm/@msgpack+msgpack@3.1.3/node_modules/@msgpack/msgpack/dist.esm/CachedKeyDecoder.mjs
  var DEFAULT_MAX_KEY_LENGTH = 16;
  var DEFAULT_MAX_LENGTH_PER_KEY = 16;
  var CachedKeyDecoder = class {
    constructor(maxKeyLength = DEFAULT_MAX_KEY_LENGTH, maxLengthPerKey = DEFAULT_MAX_LENGTH_PER_KEY) {
      __publicField(this, "hit", 0);
      __publicField(this, "miss", 0);
      __publicField(this, "caches");
      __publicField(this, "maxKeyLength");
      __publicField(this, "maxLengthPerKey");
      this.maxKeyLength = maxKeyLength;
      this.maxLengthPerKey = maxLengthPerKey;
      this.caches = [];
      for (let i = 0; i < this.maxKeyLength; i++) {
        this.caches.push([]);
      }
    }
    canBeCached(byteLength) {
      return byteLength > 0 && byteLength <= this.maxKeyLength;
    }
    find(bytes, inputOffset, byteLength) {
      const records = this.caches[byteLength - 1];
      FIND_CHUNK:
        for (const record of records) {
          const recordBytes = record.bytes;
          for (let j = 0; j < byteLength; j++) {
            if (recordBytes[j] !== bytes[inputOffset + j]) {
              continue FIND_CHUNK;
            }
          }
          return record.str;
        }
      return null;
    }
    store(bytes, value) {
      const records = this.caches[bytes.length - 1];
      const record = { bytes, str: value };
      if (records.length >= this.maxLengthPerKey) {
        records[Math.random() * records.length | 0] = record;
      } else {
        records.push(record);
      }
    }
    decode(bytes, inputOffset, byteLength) {
      const cachedValue = this.find(bytes, inputOffset, byteLength);
      if (cachedValue != null) {
        this.hit++;
        return cachedValue;
      }
      this.miss++;
      const str = utf8DecodeJs(bytes, inputOffset, byteLength);
      const slicedCopyOfBytes = Uint8Array.prototype.slice.call(bytes, inputOffset, inputOffset + byteLength);
      this.store(slicedCopyOfBytes, str);
      return str;
    }
  };

  // node_modules/.pnpm/@msgpack+msgpack@3.1.3/node_modules/@msgpack/msgpack/dist.esm/Decoder.mjs
  var STATE_ARRAY = "array";
  var STATE_MAP_KEY = "map_key";
  var STATE_MAP_VALUE = "map_value";
  var mapKeyConverter = (key) => {
    if (typeof key === "string" || typeof key === "number") {
      return key;
    }
    throw new DecodeError("The type of key must be string or number but " + typeof key);
  };
  var StackPool = class {
    constructor() {
      __publicField(this, "stack", []);
      __publicField(this, "stackHeadPosition", -1);
    }
    get length() {
      return this.stackHeadPosition + 1;
    }
    top() {
      return this.stack[this.stackHeadPosition];
    }
    pushArrayState(size) {
      const state = this.getUninitializedStateFromPool();
      state.type = STATE_ARRAY;
      state.position = 0;
      state.size = size;
      state.array = new Array(size);
    }
    pushMapState(size) {
      const state = this.getUninitializedStateFromPool();
      state.type = STATE_MAP_KEY;
      state.readCount = 0;
      state.size = size;
      state.map = {};
    }
    getUninitializedStateFromPool() {
      this.stackHeadPosition++;
      if (this.stackHeadPosition === this.stack.length) {
        const partialState = {
          type: void 0,
          size: 0,
          array: void 0,
          position: 0,
          readCount: 0,
          map: void 0,
          key: null
        };
        this.stack.push(partialState);
      }
      return this.stack[this.stackHeadPosition];
    }
    release(state) {
      const topStackState = this.stack[this.stackHeadPosition];
      if (topStackState !== state) {
        throw new Error("Invalid stack state. Released state is not on top of the stack.");
      }
      if (state.type === STATE_ARRAY) {
        const partialState = state;
        partialState.size = 0;
        partialState.array = void 0;
        partialState.position = 0;
        partialState.type = void 0;
      }
      if (state.type === STATE_MAP_KEY || state.type === STATE_MAP_VALUE) {
        const partialState = state;
        partialState.size = 0;
        partialState.map = void 0;
        partialState.readCount = 0;
        partialState.type = void 0;
      }
      this.stackHeadPosition--;
    }
    reset() {
      this.stack.length = 0;
      this.stackHeadPosition = -1;
    }
  };
  var HEAD_BYTE_REQUIRED = -1;
  var EMPTY_VIEW = new DataView(new ArrayBuffer(0));
  var EMPTY_BYTES = new Uint8Array(EMPTY_VIEW.buffer);
  try {
    EMPTY_VIEW.getInt8(0);
  } catch (e) {
    if (!(e instanceof RangeError)) {
      throw new Error("This module is not supported in the current JavaScript engine because DataView does not throw RangeError on out-of-bounds access");
    }
  }
  var MORE_DATA = new RangeError("Insufficient data");
  var sharedCachedKeyDecoder = new CachedKeyDecoder();
  var Decoder = class _Decoder {
    constructor(options) {
      __publicField(this, "extensionCodec");
      __publicField(this, "context");
      __publicField(this, "useBigInt64");
      __publicField(this, "rawStrings");
      __publicField(this, "maxStrLength");
      __publicField(this, "maxBinLength");
      __publicField(this, "maxArrayLength");
      __publicField(this, "maxMapLength");
      __publicField(this, "maxExtLength");
      __publicField(this, "keyDecoder");
      __publicField(this, "mapKeyConverter");
      __publicField(this, "totalPos", 0);
      __publicField(this, "pos", 0);
      __publicField(this, "view", EMPTY_VIEW);
      __publicField(this, "bytes", EMPTY_BYTES);
      __publicField(this, "headByte", HEAD_BYTE_REQUIRED);
      __publicField(this, "stack", new StackPool());
      __publicField(this, "entered", false);
      this.extensionCodec = options?.extensionCodec ?? ExtensionCodec.defaultCodec;
      this.context = options?.context;
      this.useBigInt64 = options?.useBigInt64 ?? false;
      this.rawStrings = options?.rawStrings ?? false;
      this.maxStrLength = options?.maxStrLength ?? UINT32_MAX;
      this.maxBinLength = options?.maxBinLength ?? UINT32_MAX;
      this.maxArrayLength = options?.maxArrayLength ?? UINT32_MAX;
      this.maxMapLength = options?.maxMapLength ?? UINT32_MAX;
      this.maxExtLength = options?.maxExtLength ?? UINT32_MAX;
      this.keyDecoder = options?.keyDecoder !== void 0 ? options.keyDecoder : sharedCachedKeyDecoder;
      this.mapKeyConverter = options?.mapKeyConverter ?? mapKeyConverter;
    }
    clone() {
      return new _Decoder({
        extensionCodec: this.extensionCodec,
        context: this.context,
        useBigInt64: this.useBigInt64,
        rawStrings: this.rawStrings,
        maxStrLength: this.maxStrLength,
        maxBinLength: this.maxBinLength,
        maxArrayLength: this.maxArrayLength,
        maxMapLength: this.maxMapLength,
        maxExtLength: this.maxExtLength,
        keyDecoder: this.keyDecoder
      });
    }
    reinitializeState() {
      this.totalPos = 0;
      this.headByte = HEAD_BYTE_REQUIRED;
      this.stack.reset();
    }
    setBuffer(buffer) {
      const bytes = ensureUint8Array(buffer);
      this.bytes = bytes;
      this.view = new DataView(bytes.buffer, bytes.byteOffset, bytes.byteLength);
      this.pos = 0;
    }
    appendBuffer(buffer) {
      if (this.headByte === HEAD_BYTE_REQUIRED && !this.hasRemaining(1)) {
        this.setBuffer(buffer);
      } else {
        const remainingData = this.bytes.subarray(this.pos);
        const newData = ensureUint8Array(buffer);
        const newBuffer = new Uint8Array(remainingData.length + newData.length);
        newBuffer.set(remainingData);
        newBuffer.set(newData, remainingData.length);
        this.setBuffer(newBuffer);
      }
    }
    hasRemaining(size) {
      return this.view.byteLength - this.pos >= size;
    }
    createExtraByteError(posToShow) {
      const { view, pos } = this;
      return new RangeError(`Extra ${view.byteLength - pos} of ${view.byteLength} byte(s) found at buffer[${posToShow}]`);
    }
    /**
     * @throws {@link DecodeError}
     * @throws {@link RangeError}
     */
    decode(buffer) {
      if (this.entered) {
        const instance = this.clone();
        return instance.decode(buffer);
      }
      try {
        this.entered = true;
        this.reinitializeState();
        this.setBuffer(buffer);
        const object = this.doDecodeSync();
        if (this.hasRemaining(1)) {
          throw this.createExtraByteError(this.pos);
        }
        return object;
      } finally {
        this.entered = false;
      }
    }
    *decodeMulti(buffer) {
      if (this.entered) {
        const instance = this.clone();
        yield* instance.decodeMulti(buffer);
        return;
      }
      try {
        this.entered = true;
        this.reinitializeState();
        this.setBuffer(buffer);
        while (this.hasRemaining(1)) {
          yield this.doDecodeSync();
        }
      } finally {
        this.entered = false;
      }
    }
    async decodeAsync(stream) {
      if (this.entered) {
        const instance = this.clone();
        return instance.decodeAsync(stream);
      }
      try {
        this.entered = true;
        let decoded = false;
        let object;
        for await (const buffer of stream) {
          if (decoded) {
            this.entered = false;
            throw this.createExtraByteError(this.totalPos);
          }
          this.appendBuffer(buffer);
          try {
            object = this.doDecodeSync();
            decoded = true;
          } catch (e) {
            if (!(e instanceof RangeError)) {
              throw e;
            }
          }
          this.totalPos += this.pos;
        }
        if (decoded) {
          if (this.hasRemaining(1)) {
            throw this.createExtraByteError(this.totalPos);
          }
          return object;
        }
        const { headByte, pos, totalPos } = this;
        throw new RangeError(`Insufficient data in parsing ${prettyByte(headByte)} at ${totalPos} (${pos} in the current buffer)`);
      } finally {
        this.entered = false;
      }
    }
    decodeArrayStream(stream) {
      return this.decodeMultiAsync(stream, true);
    }
    decodeStream(stream) {
      return this.decodeMultiAsync(stream, false);
    }
    async *decodeMultiAsync(stream, isArray) {
      if (this.entered) {
        const instance = this.clone();
        yield* instance.decodeMultiAsync(stream, isArray);
        return;
      }
      try {
        this.entered = true;
        let isArrayHeaderRequired = isArray;
        let arrayItemsLeft = -1;
        for await (const buffer of stream) {
          if (isArray && arrayItemsLeft === 0) {
            throw this.createExtraByteError(this.totalPos);
          }
          this.appendBuffer(buffer);
          if (isArrayHeaderRequired) {
            arrayItemsLeft = this.readArraySize();
            isArrayHeaderRequired = false;
            this.complete();
          }
          try {
            while (true) {
              yield this.doDecodeSync();
              if (--arrayItemsLeft === 0) {
                break;
              }
            }
          } catch (e) {
            if (!(e instanceof RangeError)) {
              throw e;
            }
          }
          this.totalPos += this.pos;
        }
      } finally {
        this.entered = false;
      }
    }
    doDecodeSync() {
      DECODE:
        while (true) {
          const headByte = this.readHeadByte();
          let object;
          if (headByte >= 224) {
            object = headByte - 256;
          } else if (headByte < 192) {
            if (headByte < 128) {
              object = headByte;
            } else if (headByte < 144) {
              const size = headByte - 128;
              if (size !== 0) {
                this.pushMapState(size);
                this.complete();
                continue DECODE;
              } else {
                object = {};
              }
            } else if (headByte < 160) {
              const size = headByte - 144;
              if (size !== 0) {
                this.pushArrayState(size);
                this.complete();
                continue DECODE;
              } else {
                object = [];
              }
            } else {
              const byteLength = headByte - 160;
              object = this.decodeString(byteLength, 0);
            }
          } else if (headByte === 192) {
            object = null;
          } else if (headByte === 194) {
            object = false;
          } else if (headByte === 195) {
            object = true;
          } else if (headByte === 202) {
            object = this.readF32();
          } else if (headByte === 203) {
            object = this.readF64();
          } else if (headByte === 204) {
            object = this.readU8();
          } else if (headByte === 205) {
            object = this.readU16();
          } else if (headByte === 206) {
            object = this.readU32();
          } else if (headByte === 207) {
            if (this.useBigInt64) {
              object = this.readU64AsBigInt();
            } else {
              object = this.readU64();
            }
          } else if (headByte === 208) {
            object = this.readI8();
          } else if (headByte === 209) {
            object = this.readI16();
          } else if (headByte === 210) {
            object = this.readI32();
          } else if (headByte === 211) {
            if (this.useBigInt64) {
              object = this.readI64AsBigInt();
            } else {
              object = this.readI64();
            }
          } else if (headByte === 217) {
            const byteLength = this.lookU8();
            object = this.decodeString(byteLength, 1);
          } else if (headByte === 218) {
            const byteLength = this.lookU16();
            object = this.decodeString(byteLength, 2);
          } else if (headByte === 219) {
            const byteLength = this.lookU32();
            object = this.decodeString(byteLength, 4);
          } else if (headByte === 220) {
            const size = this.readU16();
            if (size !== 0) {
              this.pushArrayState(size);
              this.complete();
              continue DECODE;
            } else {
              object = [];
            }
          } else if (headByte === 221) {
            const size = this.readU32();
            if (size !== 0) {
              this.pushArrayState(size);
              this.complete();
              continue DECODE;
            } else {
              object = [];
            }
          } else if (headByte === 222) {
            const size = this.readU16();
            if (size !== 0) {
              this.pushMapState(size);
              this.complete();
              continue DECODE;
            } else {
              object = {};
            }
          } else if (headByte === 223) {
            const size = this.readU32();
            if (size !== 0) {
              this.pushMapState(size);
              this.complete();
              continue DECODE;
            } else {
              object = {};
            }
          } else if (headByte === 196) {
            const size = this.lookU8();
            object = this.decodeBinary(size, 1);
          } else if (headByte === 197) {
            const size = this.lookU16();
            object = this.decodeBinary(size, 2);
          } else if (headByte === 198) {
            const size = this.lookU32();
            object = this.decodeBinary(size, 4);
          } else if (headByte === 212) {
            object = this.decodeExtension(1, 0);
          } else if (headByte === 213) {
            object = this.decodeExtension(2, 0);
          } else if (headByte === 214) {
            object = this.decodeExtension(4, 0);
          } else if (headByte === 215) {
            object = this.decodeExtension(8, 0);
          } else if (headByte === 216) {
            object = this.decodeExtension(16, 0);
          } else if (headByte === 199) {
            const size = this.lookU8();
            object = this.decodeExtension(size, 1);
          } else if (headByte === 200) {
            const size = this.lookU16();
            object = this.decodeExtension(size, 2);
          } else if (headByte === 201) {
            const size = this.lookU32();
            object = this.decodeExtension(size, 4);
          } else {
            throw new DecodeError(`Unrecognized type byte: ${prettyByte(headByte)}`);
          }
          this.complete();
          const stack = this.stack;
          while (stack.length > 0) {
            const state = stack.top();
            if (state.type === STATE_ARRAY) {
              state.array[state.position] = object;
              state.position++;
              if (state.position === state.size) {
                object = state.array;
                stack.release(state);
              } else {
                continue DECODE;
              }
            } else if (state.type === STATE_MAP_KEY) {
              if (object === "__proto__") {
                throw new DecodeError("The key __proto__ is not allowed");
              }
              state.key = this.mapKeyConverter(object);
              state.type = STATE_MAP_VALUE;
              continue DECODE;
            } else {
              state.map[state.key] = object;
              state.readCount++;
              if (state.readCount === state.size) {
                object = state.map;
                stack.release(state);
              } else {
                state.key = null;
                state.type = STATE_MAP_KEY;
                continue DECODE;
              }
            }
          }
          return object;
        }
    }
    readHeadByte() {
      if (this.headByte === HEAD_BYTE_REQUIRED) {
        this.headByte = this.readU8();
      }
      return this.headByte;
    }
    complete() {
      this.headByte = HEAD_BYTE_REQUIRED;
    }
    readArraySize() {
      const headByte = this.readHeadByte();
      switch (headByte) {
        case 220:
          return this.readU16();
        case 221:
          return this.readU32();
        default: {
          if (headByte < 160) {
            return headByte - 144;
          } else {
            throw new DecodeError(`Unrecognized array type byte: ${prettyByte(headByte)}`);
          }
        }
      }
    }
    pushMapState(size) {
      if (size > this.maxMapLength) {
        throw new DecodeError(`Max length exceeded: map length (${size}) > maxMapLengthLength (${this.maxMapLength})`);
      }
      this.stack.pushMapState(size);
    }
    pushArrayState(size) {
      if (size > this.maxArrayLength) {
        throw new DecodeError(`Max length exceeded: array length (${size}) > maxArrayLength (${this.maxArrayLength})`);
      }
      this.stack.pushArrayState(size);
    }
    decodeString(byteLength, headerOffset) {
      if (!this.rawStrings || this.stateIsMapKey()) {
        return this.decodeUtf8String(byteLength, headerOffset);
      }
      return this.decodeBinary(byteLength, headerOffset);
    }
    /**
     * @throws {@link RangeError}
     */
    decodeUtf8String(byteLength, headerOffset) {
      if (byteLength > this.maxStrLength) {
        throw new DecodeError(`Max length exceeded: UTF-8 byte length (${byteLength}) > maxStrLength (${this.maxStrLength})`);
      }
      if (this.bytes.byteLength < this.pos + headerOffset + byteLength) {
        throw MORE_DATA;
      }
      const offset = this.pos + headerOffset;
      let object;
      if (this.stateIsMapKey() && this.keyDecoder?.canBeCached(byteLength)) {
        object = this.keyDecoder.decode(this.bytes, offset, byteLength);
      } else {
        object = utf8Decode(this.bytes, offset, byteLength);
      }
      this.pos += headerOffset + byteLength;
      return object;
    }
    stateIsMapKey() {
      if (this.stack.length > 0) {
        const state = this.stack.top();
        return state.type === STATE_MAP_KEY;
      }
      return false;
    }
    /**
     * @throws {@link RangeError}
     */
    decodeBinary(byteLength, headOffset) {
      if (byteLength > this.maxBinLength) {
        throw new DecodeError(`Max length exceeded: bin length (${byteLength}) > maxBinLength (${this.maxBinLength})`);
      }
      if (!this.hasRemaining(byteLength + headOffset)) {
        throw MORE_DATA;
      }
      const offset = this.pos + headOffset;
      const object = this.bytes.subarray(offset, offset + byteLength);
      this.pos += headOffset + byteLength;
      return object;
    }
    decodeExtension(size, headOffset) {
      if (size > this.maxExtLength) {
        throw new DecodeError(`Max length exceeded: ext length (${size}) > maxExtLength (${this.maxExtLength})`);
      }
      const extType = this.view.getInt8(this.pos + headOffset);
      const data = this.decodeBinary(
        size,
        headOffset + 1
        /* extType */
      );
      return this.extensionCodec.decode(data, extType, this.context);
    }
    lookU8() {
      return this.view.getUint8(this.pos);
    }
    lookU16() {
      return this.view.getUint16(this.pos);
    }
    lookU32() {
      return this.view.getUint32(this.pos);
    }
    readU8() {
      const value = this.view.getUint8(this.pos);
      this.pos++;
      return value;
    }
    readI8() {
      const value = this.view.getInt8(this.pos);
      this.pos++;
      return value;
    }
    readU16() {
      const value = this.view.getUint16(this.pos);
      this.pos += 2;
      return value;
    }
    readI16() {
      const value = this.view.getInt16(this.pos);
      this.pos += 2;
      return value;
    }
    readU32() {
      const value = this.view.getUint32(this.pos);
      this.pos += 4;
      return value;
    }
    readI32() {
      const value = this.view.getInt32(this.pos);
      this.pos += 4;
      return value;
    }
    readU64() {
      const value = getUint64(this.view, this.pos);
      this.pos += 8;
      return value;
    }
    readI64() {
      const value = getInt64(this.view, this.pos);
      this.pos += 8;
      return value;
    }
    readU64AsBigInt() {
      const value = this.view.getBigUint64(this.pos);
      this.pos += 8;
      return value;
    }
    readI64AsBigInt() {
      const value = this.view.getBigInt64(this.pos);
      this.pos += 8;
      return value;
    }
    readF32() {
      const value = this.view.getFloat32(this.pos);
      this.pos += 4;
      return value;
    }
    readF64() {
      const value = this.view.getFloat64(this.pos);
      this.pos += 8;
      return value;
    }
  };

  // node_modules/.pnpm/@msgpack+msgpack@3.1.3/node_modules/@msgpack/msgpack/dist.esm/decode.mjs
  function decode(buffer, options) {
    const decoder = new Decoder(options);
    return decoder.decode(buffer);
  }

  // src/core/transports/websocket.ts
  var WebSocketTransport = class extends BaseTransport {
    constructor(url) {
      super();
      this.name = "WebSocket";
      this.socket = null;
      this.reconnectAttempts = 0;
      this.maxReconnectDelay = 5e3;
      this.shouldReconnect = true;
      this.url = url || this.getDefaultUrl();
    }
    getDefaultUrl() {
      const protocol = window.location.protocol === "https:" ? "wss:" : "ws:";
      return `${protocol}//${window.location.host}/_pyhtml/ws`;
    }
    connect() {
      return new Promise((resolve, reject) => {
        try {
          this.socket = new WebSocket(this.url);
          this.socket.binaryType = "arraybuffer";
          this.socket.onopen = () => {
            console.log("PyHTML: WebSocket connected");
            this.notifyStatus(true);
            this.reconnectAttempts = 0;
            resolve();
          };
          this.socket.onmessage = (event) => {
            try {
              const msg = decode(event.data);
              this.notifyHandlers(msg);
            } catch (e) {
              console.error("PyHTML: Error parsing WebSocket message", e);
            }
          };
          this.socket.onclose = () => {
            console.log("PyHTML: WebSocket disconnected");
            this.notifyStatus(false);
            if (this.shouldReconnect) {
              this.scheduleReconnect();
            }
          };
          this.socket.onerror = (error) => {
            console.error("PyHTML: WebSocket error", error);
            if (!this.connected) {
              reject(new Error("WebSocket connection failed"));
            }
          };
        } catch (e) {
          reject(e);
        }
      });
    }
    send(message) {
      if (this.socket && this.socket.readyState === WebSocket.OPEN) {
        this.socket.send(encode(message));
      } else {
        console.warn("PyHTML: Cannot send message, WebSocket not open");
      }
    }
    disconnect() {
      this.shouldReconnect = false;
      if (this.socket) {
        this.socket.close();
        this.socket = null;
      }
      this.notifyStatus(false);
    }
    scheduleReconnect() {
      const delay = Math.min(
        1e3 * Math.pow(2, this.reconnectAttempts),
        this.maxReconnectDelay
      );
      console.log(`PyHTML: Reconnecting in ${delay}ms...`);
      setTimeout(() => {
        this.reconnectAttempts++;
        this.connect().catch(() => {
        });
      }, delay);
    }
  };

  // src/core/transports/http.ts
  var HTTPTransport = class extends BaseTransport {
    constructor(baseUrl) {
      super();
      this.name = "HTTP";
      this.polling = false;
      this.pollAbortController = null;
      this.sessionId = null;
      this.baseUrl = baseUrl || `${window.location.origin}/_pyhtml`;
    }
    async connect() {
      try {
        const response = await fetch(`${this.baseUrl}/session`, {
          method: "POST",
          headers: {
            "Content-Type": "application/x-msgpack",
            "Accept": "application/x-msgpack"
          },
          body: encode({ path: window.location.pathname + window.location.search })
        });
        if (!response.ok) {
          throw new Error(`HTTP session init failed: ${response.status}`);
        }
        const buffer = await response.arrayBuffer();
        const data = decode(buffer);
        this.sessionId = data.sessionId;
        console.log("PyHTML: HTTP transport connected");
        this.notifyStatus(true);
        this.startPolling();
      } catch (e) {
        console.error("PyHTML: HTTP transport connection failed", e);
        throw e;
      }
    }
    async startPolling() {
      if (this.polling)
        return;
      this.polling = true;
      while (this.polling && this.connected) {
        try {
          this.pollAbortController = new AbortController();
          const response = await fetch(`${this.baseUrl}/poll?session=${this.sessionId}`, {
            method: "GET",
            signal: this.pollAbortController.signal,
            headers: {
              "Accept": "application/x-msgpack"
            }
          });
          if (!response.ok) {
            if (response.status === 404) {
              console.warn("PyHTML: HTTP session expired, reconnecting...");
              this.notifyStatus(false);
              await this.connect();
              return;
            }
            throw new Error(`Poll failed: ${response.status}`);
          }
          const buffer = await response.arrayBuffer();
          const messages = decode(buffer);
          for (const msg of messages) {
            this.notifyHandlers(msg);
          }
        } catch (e) {
          if (e instanceof Error && e.name === "AbortError") {
            break;
          }
          console.error("PyHTML: HTTP poll error", e);
          await this.sleep(1e3);
        }
      }
    }
    async send(message) {
      if (!this.connected || !this.sessionId) {
        console.warn("PyHTML: Cannot send message, HTTP transport not connected");
        return;
      }
      try {
        const response = await fetch(`${this.baseUrl}/event`, {
          method: "POST",
          headers: {
            "Content-Type": "application/x-msgpack",
            "Accept": "application/x-msgpack",
            "X-PyHTML-Session": this.sessionId
          },
          body: encode(message)
        });
        if (!response.ok) {
          throw new Error(`Event send failed: ${response.status}`);
        }
        const buffer = await response.arrayBuffer();
        const result = decode(buffer);
        this.notifyHandlers(result);
      } catch (e) {
        console.error("PyHTML: HTTP send error", e);
      }
    }
    disconnect() {
      this.polling = false;
      this.notifyStatus(false);
      if (this.pollAbortController) {
        this.pollAbortController.abort();
        this.pollAbortController = null;
      }
      this.sessionId = null;
    }
    sleep(ms) {
      return new Promise((resolve) => setTimeout(resolve, ms));
    }
  };

  // src/core/transport-manager.ts
  var DEFAULT_CONFIG = {
    enableWebTransport: true,
    enableWebSocket: true,
    enableHTTP: true
  };
  var TransportManager = class {
    constructor(config = {}) {
      this.transport = null;
      this.messageHandlers = [];
      this.statusHandlers = [];
      this.config = { ...DEFAULT_CONFIG, ...config };
    }
    /**
     * Connect using the best available transport with fallback.
     */
    async connect() {
      const transports = this.getTransportPriority();
      for (const TransportClass of transports) {
        try {
          console.log(`PyHTML: Trying ${TransportClass.name}...`);
          this.transport = new TransportClass();
          for (const handler of this.messageHandlers) {
            this.transport.onMessage(handler);
          }
          this.transport.onStatusChange((connected) => {
            this.notifyStatusHandlers(connected);
          });
          await this.transport.connect();
          console.log(`PyHTML: Connected via ${this.transport.name}`);
          return;
        } catch (e) {
          console.warn(`PyHTML: ${TransportClass.name} failed, trying next...`, e);
          this.transport = null;
        }
      }
      throw new Error("PyHTML: All transports failed");
    }
    /**
     * Get transport classes in priority order based on config and browser support.
     */
    getTransportPriority() {
      const transports = [];
      if (this.config.enableWebTransport && WebTransportTransport.isSupported()) {
        if (window.location.protocol === "https:") {
          transports.push(WebTransportTransport);
        }
      }
      if (this.config.enableWebSocket && typeof WebSocket !== "undefined") {
        transports.push(WebSocketTransport);
      }
      if (this.config.enableHTTP) {
        transports.push(HTTPTransport);
      }
      return transports;
    }
    /**
     * Send a message through the active transport.
     */
    send(message) {
      if (this.transport) {
        this.transport.send(message);
      } else {
        console.warn("PyHTML: No active transport");
      }
    }
    /**
     * Register a message handler.
     */
    onMessage(handler) {
      this.messageHandlers.push(handler);
      if (this.transport) {
        this.transport.onMessage(handler);
      }
    }
    /**
     * Register a connection status change handler.
     */
    onStatusChange(handler) {
      this.statusHandlers.push(handler);
    }
    notifyStatusHandlers(connected) {
      for (const handler of this.statusHandlers) {
        handler(connected);
      }
    }
    /**
     * Disconnect the active transport.
     */
    disconnect() {
      if (this.transport) {
        this.transport.disconnect();
        this.transport = null;
        this.notifyStatusHandlers(false);
      }
    }
    /**
     * Get the name of the active transport.
     */
    getActiveTransport() {
      return this.transport?.name || null;
    }
    /**
     * Check if connected.
     */
    isConnected() {
      return this.transport?.isConnected() || false;
    }
  };

  // node_modules/.pnpm/morphdom@2.7.7/node_modules/morphdom/dist/morphdom-esm.js
  var DOCUMENT_FRAGMENT_NODE = 11;
  function morphAttrs(fromNode, toNode) {
    var toNodeAttrs = toNode.attributes;
    var attr;
    var attrName;
    var attrNamespaceURI;
    var attrValue;
    var fromValue;
    if (toNode.nodeType === DOCUMENT_FRAGMENT_NODE || fromNode.nodeType === DOCUMENT_FRAGMENT_NODE) {
      return;
    }
    for (var i = toNodeAttrs.length - 1; i >= 0; i--) {
      attr = toNodeAttrs[i];
      attrName = attr.name;
      attrNamespaceURI = attr.namespaceURI;
      attrValue = attr.value;
      if (attrNamespaceURI) {
        attrName = attr.localName || attrName;
        fromValue = fromNode.getAttributeNS(attrNamespaceURI, attrName);
        if (fromValue !== attrValue) {
          if (attr.prefix === "xmlns") {
            attrName = attr.name;
          }
          fromNode.setAttributeNS(attrNamespaceURI, attrName, attrValue);
        }
      } else {
        fromValue = fromNode.getAttribute(attrName);
        if (fromValue !== attrValue) {
          fromNode.setAttribute(attrName, attrValue);
        }
      }
    }
    var fromNodeAttrs = fromNode.attributes;
    for (var d = fromNodeAttrs.length - 1; d >= 0; d--) {
      attr = fromNodeAttrs[d];
      attrName = attr.name;
      attrNamespaceURI = attr.namespaceURI;
      if (attrNamespaceURI) {
        attrName = attr.localName || attrName;
        if (!toNode.hasAttributeNS(attrNamespaceURI, attrName)) {
          fromNode.removeAttributeNS(attrNamespaceURI, attrName);
        }
      } else {
        if (!toNode.hasAttribute(attrName)) {
          fromNode.removeAttribute(attrName);
        }
      }
    }
  }
  var range;
  var NS_XHTML = "http://www.w3.org/1999/xhtml";
  var doc = typeof document === "undefined" ? void 0 : document;
  var HAS_TEMPLATE_SUPPORT = !!doc && "content" in doc.createElement("template");
  var HAS_RANGE_SUPPORT = !!doc && doc.createRange && "createContextualFragment" in doc.createRange();
  function createFragmentFromTemplate(str) {
    var template = doc.createElement("template");
    template.innerHTML = str;
    return template.content.childNodes[0];
  }
  function createFragmentFromRange(str) {
    if (!range) {
      range = doc.createRange();
      range.selectNode(doc.body);
    }
    var fragment = range.createContextualFragment(str);
    return fragment.childNodes[0];
  }
  function createFragmentFromWrap(str) {
    var fragment = doc.createElement("body");
    fragment.innerHTML = str;
    return fragment.childNodes[0];
  }
  function toElement(str) {
    str = str.trim();
    if (HAS_TEMPLATE_SUPPORT) {
      return createFragmentFromTemplate(str);
    } else if (HAS_RANGE_SUPPORT) {
      return createFragmentFromRange(str);
    }
    return createFragmentFromWrap(str);
  }
  function compareNodeNames(fromEl, toEl) {
    var fromNodeName = fromEl.nodeName;
    var toNodeName = toEl.nodeName;
    var fromCodeStart, toCodeStart;
    if (fromNodeName === toNodeName) {
      return true;
    }
    fromCodeStart = fromNodeName.charCodeAt(0);
    toCodeStart = toNodeName.charCodeAt(0);
    if (fromCodeStart <= 90 && toCodeStart >= 97) {
      return fromNodeName === toNodeName.toUpperCase();
    } else if (toCodeStart <= 90 && fromCodeStart >= 97) {
      return toNodeName === fromNodeName.toUpperCase();
    } else {
      return false;
    }
  }
  function createElementNS(name, namespaceURI) {
    return !namespaceURI || namespaceURI === NS_XHTML ? doc.createElement(name) : doc.createElementNS(namespaceURI, name);
  }
  function moveChildren(fromEl, toEl) {
    var curChild = fromEl.firstChild;
    while (curChild) {
      var nextChild = curChild.nextSibling;
      toEl.appendChild(curChild);
      curChild = nextChild;
    }
    return toEl;
  }
  function syncBooleanAttrProp(fromEl, toEl, name) {
    if (fromEl[name] !== toEl[name]) {
      fromEl[name] = toEl[name];
      if (fromEl[name]) {
        fromEl.setAttribute(name, "");
      } else {
        fromEl.removeAttribute(name);
      }
    }
  }
  var specialElHandlers = {
    OPTION: function(fromEl, toEl) {
      var parentNode = fromEl.parentNode;
      if (parentNode) {
        var parentName = parentNode.nodeName.toUpperCase();
        if (parentName === "OPTGROUP") {
          parentNode = parentNode.parentNode;
          parentName = parentNode && parentNode.nodeName.toUpperCase();
        }
        if (parentName === "SELECT" && !parentNode.hasAttribute("multiple")) {
          if (fromEl.hasAttribute("selected") && !toEl.selected) {
            fromEl.setAttribute("selected", "selected");
            fromEl.removeAttribute("selected");
          }
          parentNode.selectedIndex = -1;
        }
      }
      syncBooleanAttrProp(fromEl, toEl, "selected");
    },
    /**
     * The "value" attribute is special for the <input> element since it sets
     * the initial value. Changing the "value" attribute without changing the
     * "value" property will have no effect since it is only used to the set the
     * initial value.  Similar for the "checked" attribute, and "disabled".
     */
    INPUT: function(fromEl, toEl) {
      syncBooleanAttrProp(fromEl, toEl, "checked");
      syncBooleanAttrProp(fromEl, toEl, "disabled");
      if (fromEl.value !== toEl.value) {
        fromEl.value = toEl.value;
      }
      if (!toEl.hasAttribute("value")) {
        fromEl.removeAttribute("value");
      }
    },
    TEXTAREA: function(fromEl, toEl) {
      var newValue = toEl.value;
      if (fromEl.value !== newValue) {
        fromEl.value = newValue;
      }
      var firstChild = fromEl.firstChild;
      if (firstChild) {
        var oldValue = firstChild.nodeValue;
        if (oldValue == newValue || !newValue && oldValue == fromEl.placeholder) {
          return;
        }
        firstChild.nodeValue = newValue;
      }
    },
    SELECT: function(fromEl, toEl) {
      if (!toEl.hasAttribute("multiple")) {
        var selectedIndex = -1;
        var i = 0;
        var curChild = fromEl.firstChild;
        var optgroup;
        var nodeName;
        while (curChild) {
          nodeName = curChild.nodeName && curChild.nodeName.toUpperCase();
          if (nodeName === "OPTGROUP") {
            optgroup = curChild;
            curChild = optgroup.firstChild;
            if (!curChild) {
              curChild = optgroup.nextSibling;
              optgroup = null;
            }
          } else {
            if (nodeName === "OPTION") {
              if (curChild.hasAttribute("selected")) {
                selectedIndex = i;
                break;
              }
              i++;
            }
            curChild = curChild.nextSibling;
            if (!curChild && optgroup) {
              curChild = optgroup.nextSibling;
              optgroup = null;
            }
          }
        }
        fromEl.selectedIndex = selectedIndex;
      }
    }
  };
  var ELEMENT_NODE = 1;
  var DOCUMENT_FRAGMENT_NODE$1 = 11;
  var TEXT_NODE = 3;
  var COMMENT_NODE = 8;
  function noop() {
  }
  function defaultGetNodeKey(node) {
    if (node) {
      return node.getAttribute && node.getAttribute("id") || node.id;
    }
  }
  function morphdomFactory(morphAttrs2) {
    return function morphdom2(fromNode, toNode, options) {
      if (!options) {
        options = {};
      }
      if (typeof toNode === "string") {
        if (fromNode.nodeName === "#document" || fromNode.nodeName === "HTML" || fromNode.nodeName === "BODY") {
          var toNodeHtml = toNode;
          toNode = doc.createElement("html");
          toNode.innerHTML = toNodeHtml;
        } else {
          toNode = toElement(toNode);
        }
      } else if (toNode.nodeType === DOCUMENT_FRAGMENT_NODE$1) {
        toNode = toNode.firstElementChild;
      }
      var getNodeKey = options.getNodeKey || defaultGetNodeKey;
      var onBeforeNodeAdded = options.onBeforeNodeAdded || noop;
      var onNodeAdded = options.onNodeAdded || noop;
      var onBeforeElUpdated = options.onBeforeElUpdated || noop;
      var onElUpdated = options.onElUpdated || noop;
      var onBeforeNodeDiscarded = options.onBeforeNodeDiscarded || noop;
      var onNodeDiscarded = options.onNodeDiscarded || noop;
      var onBeforeElChildrenUpdated = options.onBeforeElChildrenUpdated || noop;
      var skipFromChildren = options.skipFromChildren || noop;
      var addChild = options.addChild || function(parent, child) {
        return parent.appendChild(child);
      };
      var childrenOnly = options.childrenOnly === true;
      var fromNodesLookup = /* @__PURE__ */ Object.create(null);
      var keyedRemovalList = [];
      function addKeyedRemoval(key) {
        keyedRemovalList.push(key);
      }
      function walkDiscardedChildNodes(node, skipKeyedNodes) {
        if (node.nodeType === ELEMENT_NODE) {
          var curChild = node.firstChild;
          while (curChild) {
            var key = void 0;
            if (skipKeyedNodes && (key = getNodeKey(curChild))) {
              addKeyedRemoval(key);
            } else {
              onNodeDiscarded(curChild);
              if (curChild.firstChild) {
                walkDiscardedChildNodes(curChild, skipKeyedNodes);
              }
            }
            curChild = curChild.nextSibling;
          }
        }
      }
      function removeNode(node, parentNode, skipKeyedNodes) {
        if (onBeforeNodeDiscarded(node) === false) {
          return;
        }
        if (parentNode) {
          parentNode.removeChild(node);
        }
        onNodeDiscarded(node);
        walkDiscardedChildNodes(node, skipKeyedNodes);
      }
      function indexTree(node) {
        if (node.nodeType === ELEMENT_NODE || node.nodeType === DOCUMENT_FRAGMENT_NODE$1) {
          var curChild = node.firstChild;
          while (curChild) {
            var key = getNodeKey(curChild);
            if (key) {
              fromNodesLookup[key] = curChild;
            }
            indexTree(curChild);
            curChild = curChild.nextSibling;
          }
        }
      }
      indexTree(fromNode);
      function handleNodeAdded(el) {
        onNodeAdded(el);
        var curChild = el.firstChild;
        while (curChild) {
          var nextSibling = curChild.nextSibling;
          var key = getNodeKey(curChild);
          if (key) {
            var unmatchedFromEl = fromNodesLookup[key];
            if (unmatchedFromEl && compareNodeNames(curChild, unmatchedFromEl)) {
              curChild.parentNode.replaceChild(unmatchedFromEl, curChild);
              morphEl(unmatchedFromEl, curChild);
            } else {
              handleNodeAdded(curChild);
            }
          } else {
            handleNodeAdded(curChild);
          }
          curChild = nextSibling;
        }
      }
      function cleanupFromEl(fromEl, curFromNodeChild, curFromNodeKey) {
        while (curFromNodeChild) {
          var fromNextSibling = curFromNodeChild.nextSibling;
          if (curFromNodeKey = getNodeKey(curFromNodeChild)) {
            addKeyedRemoval(curFromNodeKey);
          } else {
            removeNode(
              curFromNodeChild,
              fromEl,
              true
              /* skip keyed nodes */
            );
          }
          curFromNodeChild = fromNextSibling;
        }
      }
      function morphEl(fromEl, toEl, childrenOnly2) {
        var toElKey = getNodeKey(toEl);
        if (toElKey) {
          delete fromNodesLookup[toElKey];
        }
        if (!childrenOnly2) {
          var beforeUpdateResult = onBeforeElUpdated(fromEl, toEl);
          if (beforeUpdateResult === false) {
            return;
          } else if (beforeUpdateResult instanceof HTMLElement) {
            fromEl = beforeUpdateResult;
            indexTree(fromEl);
          }
          morphAttrs2(fromEl, toEl);
          onElUpdated(fromEl);
          if (onBeforeElChildrenUpdated(fromEl, toEl) === false) {
            return;
          }
        }
        if (fromEl.nodeName !== "TEXTAREA") {
          morphChildren(fromEl, toEl);
        } else {
          specialElHandlers.TEXTAREA(fromEl, toEl);
        }
      }
      function morphChildren(fromEl, toEl) {
        var skipFrom = skipFromChildren(fromEl, toEl);
        var curToNodeChild = toEl.firstChild;
        var curFromNodeChild = fromEl.firstChild;
        var curToNodeKey;
        var curFromNodeKey;
        var fromNextSibling;
        var toNextSibling;
        var matchingFromEl;
        outer:
          while (curToNodeChild) {
            toNextSibling = curToNodeChild.nextSibling;
            curToNodeKey = getNodeKey(curToNodeChild);
            while (!skipFrom && curFromNodeChild) {
              fromNextSibling = curFromNodeChild.nextSibling;
              if (curToNodeChild.isSameNode && curToNodeChild.isSameNode(curFromNodeChild)) {
                curToNodeChild = toNextSibling;
                curFromNodeChild = fromNextSibling;
                continue outer;
              }
              curFromNodeKey = getNodeKey(curFromNodeChild);
              var curFromNodeType = curFromNodeChild.nodeType;
              var isCompatible = void 0;
              if (curFromNodeType === curToNodeChild.nodeType) {
                if (curFromNodeType === ELEMENT_NODE) {
                  if (curToNodeKey) {
                    if (curToNodeKey !== curFromNodeKey) {
                      if (matchingFromEl = fromNodesLookup[curToNodeKey]) {
                        if (fromNextSibling === matchingFromEl) {
                          isCompatible = false;
                        } else {
                          fromEl.insertBefore(matchingFromEl, curFromNodeChild);
                          if (curFromNodeKey) {
                            addKeyedRemoval(curFromNodeKey);
                          } else {
                            removeNode(
                              curFromNodeChild,
                              fromEl,
                              true
                              /* skip keyed nodes */
                            );
                          }
                          curFromNodeChild = matchingFromEl;
                          curFromNodeKey = getNodeKey(curFromNodeChild);
                        }
                      } else {
                        isCompatible = false;
                      }
                    }
                  } else if (curFromNodeKey) {
                    isCompatible = false;
                  }
                  isCompatible = isCompatible !== false && compareNodeNames(curFromNodeChild, curToNodeChild);
                  if (isCompatible) {
                    morphEl(curFromNodeChild, curToNodeChild);
                  }
                } else if (curFromNodeType === TEXT_NODE || curFromNodeType == COMMENT_NODE) {
                  isCompatible = true;
                  if (curFromNodeChild.nodeValue !== curToNodeChild.nodeValue) {
                    curFromNodeChild.nodeValue = curToNodeChild.nodeValue;
                  }
                }
              }
              if (isCompatible) {
                curToNodeChild = toNextSibling;
                curFromNodeChild = fromNextSibling;
                continue outer;
              }
              if (curFromNodeKey) {
                addKeyedRemoval(curFromNodeKey);
              } else {
                removeNode(
                  curFromNodeChild,
                  fromEl,
                  true
                  /* skip keyed nodes */
                );
              }
              curFromNodeChild = fromNextSibling;
            }
            if (curToNodeKey && (matchingFromEl = fromNodesLookup[curToNodeKey]) && compareNodeNames(matchingFromEl, curToNodeChild)) {
              if (!skipFrom) {
                addChild(fromEl, matchingFromEl);
              }
              morphEl(matchingFromEl, curToNodeChild);
            } else {
              var onBeforeNodeAddedResult = onBeforeNodeAdded(curToNodeChild);
              if (onBeforeNodeAddedResult !== false) {
                if (onBeforeNodeAddedResult) {
                  curToNodeChild = onBeforeNodeAddedResult;
                }
                if (curToNodeChild.actualize) {
                  curToNodeChild = curToNodeChild.actualize(fromEl.ownerDocument || doc);
                }
                addChild(fromEl, curToNodeChild);
                handleNodeAdded(curToNodeChild);
              }
            }
            curToNodeChild = toNextSibling;
            curFromNodeChild = fromNextSibling;
          }
        cleanupFromEl(fromEl, curFromNodeChild, curFromNodeKey);
        var specialElHandler = specialElHandlers[fromEl.nodeName];
        if (specialElHandler) {
          specialElHandler(fromEl, toEl);
        }
      }
      var morphedNode = fromNode;
      var morphedNodeType = morphedNode.nodeType;
      var toNodeType = toNode.nodeType;
      if (!childrenOnly) {
        if (morphedNodeType === ELEMENT_NODE) {
          if (toNodeType === ELEMENT_NODE) {
            if (!compareNodeNames(fromNode, toNode)) {
              onNodeDiscarded(fromNode);
              morphedNode = moveChildren(fromNode, createElementNS(toNode.nodeName, toNode.namespaceURI));
            }
          } else {
            morphedNode = toNode;
          }
        } else if (morphedNodeType === TEXT_NODE || morphedNodeType === COMMENT_NODE) {
          if (toNodeType === morphedNodeType) {
            if (morphedNode.nodeValue !== toNode.nodeValue) {
              morphedNode.nodeValue = toNode.nodeValue;
            }
            return morphedNode;
          } else {
            morphedNode = toNode;
          }
        }
      }
      if (morphedNode === toNode) {
        onNodeDiscarded(fromNode);
      } else {
        if (toNode.isSameNode && toNode.isSameNode(morphedNode)) {
          return;
        }
        morphEl(morphedNode, toNode, childrenOnly);
        if (keyedRemovalList) {
          for (var i = 0, len = keyedRemovalList.length; i < len; i++) {
            var elToRemove = fromNodesLookup[keyedRemovalList[i]];
            if (elToRemove) {
              removeNode(elToRemove, elToRemove.parentNode, false);
            }
          }
        }
      }
      if (!childrenOnly && morphedNode !== fromNode && fromNode.parentNode) {
        if (morphedNode.actualize) {
          morphedNode = morphedNode.actualize(fromNode.ownerDocument || doc);
        }
        fromNode.parentNode.replaceChild(morphedNode, fromNode);
      }
      return morphedNode;
    };
  }
  var morphdom = morphdomFactory(morphAttrs);
  var morphdom_esm_default = morphdom;

  // src/core/dom-updater.ts
  var _DOMUpdater = class _DOMUpdater {
    constructor(debug = false) {
      this.debug = debug;
    }
    /**
     * Generate a stable key for an element.
     * Used by morphdom to match elements between old and new DOM.
     */
    getNodeKey(node) {
      if (!(node instanceof HTMLElement))
        return void 0;
      for (const attr of node.attributes) {
        if (attr.name.startsWith("data-on-")) {
          const key = `${node.tagName}-${attr.name}-${attr.value}`;
          return key;
        }
      }
      if (node.id && !node.id.startsWith("pyhtml-uid-")) {
        return node.id;
      }
      if (node instanceof HTMLInputElement || node instanceof HTMLSelectElement || node instanceof HTMLTextAreaElement) {
        if (node.name) {
          return `${node.tagName}-name-${node.name}`;
        }
      }
      return void 0;
    }
    /**
     * Generate a selector to find an element
     */
    getElementSelector(el) {
      if (el.id)
        return `#${el.id}`;
      const path = [];
      let current = el;
      while (current && current !== document.body && path.length < 5) {
        let selector = current.tagName.toLowerCase();
        if (current.id) {
          selector = `#${current.id}`;
          path.unshift(selector);
          break;
        }
        if (current instanceof HTMLInputElement || current instanceof HTMLSelectElement || current instanceof HTMLTextAreaElement) {
          if (current.name) {
            selector += `[name="${current.name}"]`;
          }
        }
        for (const attr of current.attributes) {
          if (attr.name.startsWith("data-on-")) {
            selector += `[${attr.name}="${attr.value}"]`;
            break;
          }
        }
        if (current.parentElement) {
          const sibs = Array.from(current.parentElement.children);
          const sameTags = sibs.filter((s) => s.tagName === current.tagName);
          if (sameTags.length > 1) {
            const idx = sameTags.indexOf(current) + 1;
            selector += `:nth-of-type(${idx})`;
          }
        }
        path.unshift(selector);
        current = current.parentElement;
      }
      return path.join(" > ");
    }
    /**
     * Capture the current focus state before updating.
     */
    captureFocusState() {
      const active = document.activeElement;
      if (!active || active === document.body || active === document.documentElement)
        return null;
      const state = {
        selector: this.getElementSelector(active),
        id: active.id || null,
        tagName: active.tagName,
        selectionStart: null,
        selectionEnd: null,
        scrollTop: 0,
        scrollLeft: 0,
        value: ""
      };
      if (active instanceof HTMLInputElement || active instanceof HTMLTextAreaElement) {
        state.selectionStart = active.selectionStart;
        state.selectionEnd = active.selectionEnd;
        state.scrollTop = active.scrollTop;
        state.scrollLeft = active.scrollLeft;
        state.value = active.value;
      }
      return state;
    }
    /**
     * Restore focus state after updating.
     */
    restoreFocusState(state) {
      if (!state)
        return;
      let el = null;
      if (state.id) {
        el = document.getElementById(state.id);
      }
      if (!el && state.selector) {
        try {
          el = document.querySelector(state.selector);
        } catch (e) {
        }
      }
      if (!el)
        return;
      el.focus();
      if (el instanceof HTMLInputElement || el instanceof HTMLTextAreaElement) {
        if (state.value && el.value !== state.value) {
          el.value = state.value;
        }
        if (state.selectionStart !== null && state.selectionEnd !== null) {
          try {
            el.setSelectionRange(state.selectionStart, state.selectionEnd);
          } catch (e) {
          }
        }
        el.scrollTop = state.scrollTop;
        el.scrollLeft = state.scrollLeft;
      }
    }
    /**
     * Update the DOM with new HTML content.
     */
    update(newHtml) {
      _DOMUpdater.isUpdating = true;
      if (this.debug) {
        console.log("[DOMUpdater] Starting update, isUpdating =", _DOMUpdater.isUpdating);
      }
      try {
        const focusState = this.captureFocusState();
        const formStates = /* @__PURE__ */ new Map();
        document.querySelectorAll("input, select, textarea").forEach((el, idx) => {
          const key = this.getNodeKey(el) || `form-el-${idx}`;
          if (el instanceof HTMLInputElement) {
            formStates.set(key, {
              value: el.value,
              checked: el.type === "checkbox" || el.type === "radio" ? el.checked : void 0
            });
          } else if (el instanceof HTMLSelectElement) {
            formStates.set(key, { value: el.value, selectedIndex: el.selectedIndex });
          } else if (el instanceof HTMLTextAreaElement) {
            formStates.set(key, { value: el.value });
          }
        });
        if (morphdom_esm_default) {
          try {
            morphdom_esm_default(document.documentElement, newHtml, {
              // Custom key function for stable element matching
              getNodeKey: (node) => this.getNodeKey(node),
              onBeforeElUpdated: (fromEl, toEl) => {
                if (fromEl instanceof HTMLInputElement && toEl instanceof HTMLInputElement) {
                  if (fromEl.type === "checkbox" || fromEl.type === "radio") {
                    toEl.checked = fromEl.checked;
                  } else {
                    const s = toEl.value || "";
                    const c = fromEl.value || "";
                    if (c.startsWith(s) || s.startsWith(c)) {
                      toEl.value = c;
                    }
                  }
                }
                if (fromEl instanceof HTMLTextAreaElement && toEl instanceof HTMLTextAreaElement) {
                  const s = toEl.value || "";
                  const c = fromEl.value || "";
                  if (c.startsWith(s) || s.startsWith(c)) {
                    toEl.value = c;
                  }
                }
                if (fromEl instanceof HTMLSelectElement && toEl instanceof HTMLSelectElement) {
                  if (fromEl.value && Array.from(toEl.options).some((o) => o.value === fromEl.value)) {
                    toEl.value = fromEl.value;
                  } else if (fromEl.selectedIndex >= 0 && fromEl.selectedIndex < toEl.options.length) {
                    toEl.selectedIndex = fromEl.selectedIndex;
                  }
                }
                if (fromEl.id && fromEl.id.startsWith("pyhtml-uid-") && !toEl.id) {
                  toEl.id = fromEl.id;
                }
                return true;
              },
              onBeforeNodeDiscarded: () => true
            });
          } catch (e) {
            console.error("Morphdom failed:", e);
            document.open();
            document.write(newHtml);
            document.close();
          }
          this.restoreFocusState(focusState);
        } else {
          document.open();
          document.write(newHtml);
          document.close();
        }
      } finally {
        setTimeout(() => {
          _DOMUpdater.isUpdating = false;
        }, 0);
      }
    }
  };
  /**
   * Flag to indicate DOM is being updated.
   * Event handlers should check this to avoid triggering events during updates.
   */
  _DOMUpdater.isUpdating = false;
  var DOMUpdater = _DOMUpdater;

  // src/events/handler.ts
  var UnifiedEventHandler = class {
    constructor(app2) {
      this.debouncers = /* @__PURE__ */ new Map();
      this.throttlers = /* @__PURE__ */ new Map();
      this.supportedEvents = [
        "click",
        "submit",
        "input",
        "change",
        "keydown",
        "keyup",
        "focus",
        "blur",
        "mouseenter",
        "mouseleave",
        "scroll",
        "contextmenu"
      ];
      // Events that should be suppressed during DOM updates to prevent loops
      this.suppressDuringUpdate = ["focus", "blur", "mouseenter", "mouseleave"];
      this.app = app2;
    }
    debugLog(...args) {
      if (this.app.getConfig().debug) {
        console.log(...args);
      }
    }
    /**
     * Initialize global event listeners.
     * Uses event delegation on document body.
     */
    init() {
      this.supportedEvents.forEach((eventType) => {
        const options = eventType === "mouseenter" || eventType === "mouseleave" || eventType === "focus" || eventType === "blur" || eventType === "scroll" ? { capture: true } : void 0;
        document.addEventListener(eventType, (e) => this.handleEvent(e), options);
      });
    }
    /**
     * Helper to parse handlers from element (legacy or multiple/JSON).
     */
    getHandlers(element, eventType) {
      const handlerAttr = `data-on-${eventType}`;
      const attrValue = element.getAttribute(handlerAttr);
      if (!attrValue)
        return [];
      if (attrValue.trim().startsWith("[")) {
        try {
          const handlers = JSON.parse(attrValue);
          if (Array.isArray(handlers)) {
            return handlers.map((h) => ({
              name: h.handler,
              modifiers: h.modifiers || [],
              args: h.args
            }));
          }
        } catch (e) {
          console.error("Error parsing event handlers:", e);
        }
      } else {
        const modifiersAttr = element.getAttribute(`data-modifiers-${eventType}`);
        const modifiers = modifiersAttr ? modifiersAttr.split(" ").filter((m) => m) : [];
        return [{ name: attrValue, modifiers, args: void 0 }];
      }
      return [];
    }
    /**
     * Main event handler.
     */
    async handleEvent(e) {
      const eventType = e.type;
      if (DOMUpdater.isUpdating && this.suppressDuringUpdate.includes(eventType)) {
        this.debugLog("[Handler] SUPPRESSING event during update:", eventType, "isUpdating=", DOMUpdater.isUpdating);
        return;
      }
      this.debugLog("[Handler] Processing event:", eventType, "isUpdating=", DOMUpdater.isUpdating);
      const path = e.composedPath ? e.composedPath() : [];
      let propagationStopped = false;
      for (const node of path) {
        if (propagationStopped)
          break;
        if (node instanceof HTMLElement) {
          const element = node;
          const handlers = this.getHandlers(element, eventType);
          if (handlers.length > 0) {
            this.debugLog("[handleEvent] Found handlers on", element.tagName, handlers);
            for (const h of handlers) {
              if (!h.modifiers.includes("window") && !h.modifiers.includes("outside")) {
                this.processEvent(element, eventType, h.name, h.modifiers, e, h.args);
                if (e.cancelBubble)
                  propagationStopped = true;
              }
            }
          }
        }
      }
      this.handleGlobalEvent(e);
    }
    /**
     * Handle modifiers that listen outside the normal delegation path.
     */
    handleGlobalEvent(e) {
      const eventType = e.type;
      const windowSelector = `[data-modifiers-${eventType}*="window"]`;
      const outsideSelector = `[data-modifiers-${eventType}*="outside"]`;
      const candidates = document.querySelectorAll(`${windowSelector}, ${outsideSelector}`);
      candidates.forEach((el) => {
        if (!(el instanceof HTMLElement))
          return;
        const handlers = this.getHandlers(el, eventType);
        for (const h of handlers) {
          if (h.modifiers.includes("window")) {
            this.processEvent(el, eventType, h.name, h.modifiers, e, h.args);
          }
          if (h.modifiers.includes("outside")) {
            const target = e.target;
            if (target && !el.contains(target)) {
              this.processEvent(el, eventType, h.name, h.modifiers, e, h.args);
            }
          }
        }
      });
    }
    /**
     * Process an event for a specific element after it has been matched.
     */
    processEvent(element, eventType, handlerName, modifiers, e, explicitArgs) {
      this.debugLog("[processEvent]", eventType, "handler:", handlerName, "modifiers:", modifiers);
      if (modifiers.includes("prevent") || eventType === "submit") {
        this.debugLog("[processEvent] Calling preventDefault");
        e.preventDefault();
      }
      if (modifiers.includes("stop")) {
        e.stopPropagation();
      }
      if (modifiers.includes("self")) {
        if (e.target !== element)
          return;
      }
      if (modifiers.includes("shift") && !e.shiftKey)
        return;
      if (modifiers.includes("ctrl") && !e.ctrlKey)
        return;
      if (modifiers.includes("alt") && !e.altKey)
        return;
      if (modifiers.includes("meta") && !e.metaKey)
        return;
      if (modifiers.includes("cmd") && !e.metaKey)
        return;
      if (e instanceof KeyboardEvent) {
        const knownKeys = ["enter", "escape", "space", "tab", "up", "down", "left", "right"];
        const systemMods = ["shift", "ctrl", "alt", "meta", "cmd", "window", "outside", "prevent", "stop", "self", "debounce", "throttle"];
        const keyModifiers = modifiers.filter((m) => {
          if (systemMods.includes(m))
            return false;
          if (m.startsWith("debounce") || m.startsWith("throttle"))
            return false;
          if (m.endsWith("ms"))
            return false;
          return knownKeys.includes(m) || m.length === 1;
        });
        if (keyModifiers.length > 0) {
          const pressedKey = e.key.toLowerCase();
          this.debugLog("[processEvent] Key check. Pressed:", pressedKey, "Modifiers:", keyModifiers);
          const keyMap = {
            "escape": "escape",
            "esc": "escape",
            "enter": "enter",
            "space": " ",
            "spacebar": " ",
            " ": " ",
            "tab": "tab",
            "up": "arrowup",
            "arrowup": "arrowup",
            "down": "arrowdown",
            "arrowdown": "arrowdown",
            "left": "arrowleft",
            "arrowleft": "arrowleft",
            "right": "arrowright",
            "arrowright": "arrowright"
          };
          const normalizedPressedKey = keyMap[pressedKey] || pressedKey;
          let match = false;
          for (const constraint of keyModifiers) {
            const targetKey = keyMap[constraint] || constraint;
            this.debugLog("[processEvent] Comparing constraint:", constraint, "->", targetKey, "vs", normalizedPressedKey, "code:", e.code);
            if (targetKey === normalizedPressedKey) {
              match = true;
              break;
            }
            if (e.code && e.code.toLowerCase() === `key${targetKey}`) {
              match = true;
              break;
            }
          }
          if (!match) {
            this.debugLog("[processEvent] No key match found.");
            return;
          }
        }
      }
      const debounceMod = modifiers.find((m) => m.startsWith("debounce"));
      const throttleMod = modifiers.find((m) => m.startsWith("throttle"));
      const elementId = element.id || this.getUniqueId(element);
      const eventKey = `${elementId}-${eventType}-${handlerName}`;
      if (debounceMod) {
        const duration = this.parseDuration(modifiers, 250);
        if (this.debouncers.has(eventKey)) {
          window.clearTimeout(this.debouncers.get(eventKey));
        }
        const timer = window.setTimeout(() => {
          this.debouncers.delete(eventKey);
          this.dispatchEvent(element, eventType, handlerName, e, explicitArgs);
        }, duration);
        this.debouncers.set(eventKey, timer);
        return;
      }
      if (throttleMod) {
        const duration = this.parseDuration(modifiers, 250);
        if (this.throttlers.has(eventKey))
          return;
        this.throttlers.set(eventKey, Date.now());
        this.dispatchEvent(element, eventType, handlerName, e, explicitArgs);
        window.setTimeout(() => {
          this.throttlers.delete(eventKey);
        }, duration);
        return;
      }
      this.dispatchEvent(element, eventType, handlerName, e, explicitArgs);
    }
    /**
     * Extract data and send event.
     */
    dispatchEvent(element, eventType, handler, e, explicitArgs) {
      let args = {};
      if (explicitArgs && explicitArgs.length > 0) {
        explicitArgs.forEach((val, i) => {
          args[`arg${i}`] = val;
        });
      } else {
        args = this.getArgs(element);
      }
      const eventData = {
        type: eventType,
        id: element.id,
        args
      };
      if (element instanceof HTMLInputElement) {
        eventData.value = element.value;
        if (element.type === "checkbox" || element.type === "radio") {
          eventData.checked = element.checked;
        }
      } else if (element instanceof HTMLTextAreaElement || element instanceof HTMLSelectElement) {
        eventData.value = element.value;
      }
      if (e instanceof KeyboardEvent) {
        eventData.key = e.key;
        eventData.keyCode = e.keyCode;
      }
      if (eventType === "submit" && element instanceof HTMLFormElement) {
        const formData = new FormData(element);
        const data = {};
        formData.forEach((value, key) => {
          if (!(value instanceof File)) {
            data[key] = value.toString();
          }
        });
        eventData.formData = data;
      }
      this.app.sendEvent(handler, eventData);
    }
    parseDuration(modifiers, defaultDuration) {
      const debounceIdx = modifiers.findIndex((m) => m.startsWith("debounce"));
      const throttleIdx = modifiers.findIndex((m) => m.startsWith("throttle"));
      const idx = debounceIdx !== -1 ? debounceIdx : throttleIdx;
      if (idx !== -1 && modifiers[idx + 1]) {
        const next = modifiers[idx + 1];
        if (next.endsWith("ms")) {
          const val = parseInt(next);
          if (!isNaN(val))
            return val;
        }
      }
      const mod = modifiers[idx];
      if (mod && mod.includes("-")) {
        const parts = mod.split("-");
        const val = parseInt(parts[1]);
        if (!isNaN(val))
          return val;
      }
      return defaultDuration;
    }
    getUniqueId(element) {
      if (!element.id) {
        element.id = "pyhtml-uid-" + Math.random().toString(36).substr(2, 9);
      }
      return element.id;
    }
    getArgs(element) {
      const args = {};
      if (element instanceof HTMLElement) {
        for (const key in element.dataset) {
          if (key.startsWith("arg")) {
            try {
              args[key] = JSON.parse(element.dataset[key] || "null");
            } catch (e) {
              args[key] = element.dataset[key];
            }
          }
        }
      }
      return args;
    }
  };

  // src/core/app.ts
  var DEFAULT_CONFIG2 = {
    autoInit: true,
    enableWebTransport: true,
    enableWebSocket: true,
    enableHTTP: true,
    debug: false
  };
  var PyHTMLApp = class {
    constructor(config = {}) {
      this.initialized = false;
      this.siblingPaths = [];
      this.pathRegexes = [];
      this.pjaxEnabled = false;
      this.isConnected = false;
      this.config = { ...DEFAULT_CONFIG2, ...config };
      this.transport = new TransportManager(this.config);
      this.updater = new DOMUpdater(this.config.debug);
      this.eventHandler = new UnifiedEventHandler(this);
    }
    getConfig() {
      return this.config;
    }
    /**
     * Initialize the PyHTML application.
     */
    async init() {
      if (this.initialized)
        return;
      this.initialized = true;
      this.transport.onMessage((msg) => this.handleMessage(msg));
      this.transport.onStatusChange((connected) => this.handleStatusChange(connected));
      try {
        await this.transport.connect();
      } catch (e) {
        console.error("PyHTML: Failed to connect:", e);
      }
      this.loadSPAMetadata();
      this.setupSPANavigation();
      this.eventHandler.init();
      console.log(`PyHTML: Initialized (transport: ${this.transport.getActiveTransport()}, spa_paths: ${this.siblingPaths.length}, pjax: ${this.pjaxEnabled})`);
    }
    /**
     * Handle connection status changes. Override in dev bundle for UI.
     */
    handleStatusChange(connected) {
      this.isConnected = connected;
    }
    /**
     * Load SPA navigation metadata from injected script tag.
     */
    loadSPAMetadata() {
      const metaScript = document.getElementById("_pyhtml_spa_meta");
      if (metaScript) {
        try {
          const meta = JSON.parse(metaScript.textContent || "{}");
          this.siblingPaths = meta.sibling_paths || [];
          this.pjaxEnabled = !!meta.enable_pjax;
          if (meta.debug !== void 0) {
            this.config.debug = !!meta.debug;
          }
          this.pathRegexes = this.siblingPaths.map((p) => this.patternToRegex(p));
        } catch (e) {
          console.warn("PyHTML: Failed to parse SPA metadata", e);
        }
      }
    }
    /**
     * Convert route pattern like '/a/:id' to regex.
     */
    patternToRegex(pattern) {
      let regex = pattern.replace(/[.+?^${}()|[\]\\]/g, "\\$&");
      regex = regex.replace(/:(\\w+)(:\\w+)?/g, "([^/]+)");
      regex = regex.replace(/\\{(\\w+)(:\\w+)?\\}/g, "([^/]+)");
      return new RegExp(`^${regex}$`);
    }
    /**
     * Check if a path matches any sibling path pattern.
     */
    isSiblingPath(path) {
      return this.pathRegexes.some((regex) => regex.test(path));
    }
    /**
     * Setup SPA navigation for sibling paths.
     */
    setupSPANavigation() {
      window.addEventListener("popstate", () => {
        this.sendRelocate(window.location.pathname + window.location.search);
      });
      if (this.siblingPaths.length === 0 && !this.pjaxEnabled)
        return;
      document.addEventListener("click", (e) => {
        const link = e.target.closest("a[href]");
        if (!link)
          return;
        if (link.origin !== window.location.origin)
          return;
        if (link.hasAttribute("download") || link.target === "_blank")
          return;
        let shouldIntercept = false;
        if (this.pjaxEnabled) {
          shouldIntercept = true;
        } else if (this.isSiblingPath(link.pathname)) {
          shouldIntercept = true;
        }
        if (shouldIntercept) {
          e.preventDefault();
          this.navigateTo(link.pathname + link.search);
        }
      });
    }
    /**
     * Navigate to a path using SPA navigation.
     */
    navigateTo(path) {
      if (!this.isConnected) {
        console.warn("PyHTML: Navigation blocked - Offline");
        return;
      }
      history.pushState({}, "", path);
      this.sendRelocate(path);
    }
    /**
     * Send relocate message to server.
     */
    sendRelocate(path) {
      const message = {
        type: "relocate",
        path
      };
      this.transport.send(message);
    }
    /**
     * Send an event to the server.
     */
    sendEvent(handler, data) {
      const message = {
        type: "event",
        handler,
        path: window.location.pathname + window.location.search,
        data
      };
      this.transport.send(message);
    }
    /**
     * Handle incoming server message. Override in dev bundle for error_trace.
     */
    async handleMessage(msg) {
      switch (msg.type) {
        case "update":
          if (msg.html) {
            this.updater.update(msg.html);
          }
          break;
        case "reload":
          console.log("PyHTML: Reloading...");
          window.location.reload();
          break;
        case "error":
          console.error("PyHTML: Server error:", msg.error);
          break;
        case "error_trace":
          console.error("PyHTML: Error:", msg.error);
          break;
        case "console":
          if (msg.lines && msg.lines.length > 0) {
            const prefix = "PyHTML Server:";
            const joined = msg.lines.join("\n");
            if (msg.level === "error") {
              console.error(prefix, joined);
            } else if (msg.level === "warn") {
              console.warn(prefix, joined);
            } else {
              console.log(prefix, joined);
            }
          }
          break;
        default:
          console.warn("PyHTML: Unknown message type", msg);
      }
    }
    /**
     * Get the current transport name.
     */
    getTransport() {
      return this.transport.getActiveTransport();
    }
    /**
     * Disconnect from the server.
     */
    disconnect() {
      this.transport.disconnect();
    }
  };

  // src/pyhtml.core.ts
  var app = new PyHTMLApp();
  if (document.readyState === "loading") {
    document.addEventListener("DOMContentLoaded", () => app.init());
  } else {
    app.init();
  }
  return __toCommonJS(pyhtml_core_exports);
})();
//# sourceMappingURL=pyhtml.core.min.js.map
