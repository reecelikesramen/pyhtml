/* PyHTML Client v0.0.1 - https://github.com/reecelikesramen/pyhtml */
"use strict";
var PyHTML = (() => {
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __export = (target, all) => {
    for (var name in all)
      __defProp(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

  // src/index.ts
  var src_exports = {};
  __export(src_exports, {
    DOMUpdater: () => DOMUpdater,
    HTTPTransport: () => HTTPTransport,
    PyHTMLApp: () => PyHTMLApp,
    TransportManager: () => TransportManager,
    WebSocketTransport: () => WebSocketTransport,
    WebTransportTransport: () => WebTransportTransport,
    app: () => app
  });

  // src/transports/base.ts
  var BaseTransport = class {
    constructor() {
      this.messageHandlers = [];
      this.connected = false;
    }
    onMessage(handler) {
      this.messageHandlers.push(handler);
    }
    isConnected() {
      return this.connected;
    }
    notifyHandlers(message) {
      for (const handler of this.messageHandlers) {
        try {
          handler(message);
        } catch (e) {
          console.error("PyHTML: Error in message handler", e);
        }
      }
    }
  };

  // src/transports/webtransport.ts
  var WebTransportTransport = class _WebTransportTransport extends BaseTransport {
    constructor(url) {
      super();
      this.name = "WebTransport";
      this.transport = null;
      this.writer = null;
      this.encoder = new TextEncoder();
      this.decoder = new TextDecoder();
      this.url = url || this.getDefaultUrl();
    }
    getDefaultUrl() {
      return `https://${window.location.host}/_pyhtml/webtransport`;
    }
    /**
     * Check if WebTransport is available in this browser.
     */
    static isSupported() {
      return typeof WebTransport !== "undefined";
    }
    async connect() {
      if (!_WebTransportTransport.isSupported()) {
        throw new Error("WebTransport not supported in this browser");
      }
      try {
        const options = {};
        const certHash = window.PYHTML_CERT_HASH;
        if (certHash && Array.isArray(certHash)) {
          options.serverCertificateHashes = [{
            algorithm: "sha-256",
            value: new Uint8Array(certHash)
          }];
          console.log("PyHTML: Using explicit certificate hash for WebTransport");
        }
        this.transport = new WebTransport(this.url, options);
        await this.transport.ready;
        console.log("PyHTML: WebTransport ready");
        this.connected = true;
        this.startReading();
      } catch (e) {
        this.handleDisconnect();
        throw e;
      }
    }
    async startReading() {
      if (!this.transport)
        return;
      const reader = this.transport.incomingBidirectionalStreams.getReader();
      try {
        while (true) {
          const { value: stream, done } = await reader.read();
          if (done)
            break;
          this.handleStream(stream);
        }
      } catch (e) {
        if (this.connected) {
          console.error("PyHTML: WebTransport read error", e);
          this.handleDisconnect();
        }
      }
    }
    async handleStream(stream) {
      const reader = stream.readable.getReader();
      try {
        while (true) {
          const { value, done } = await reader.read();
          if (done)
            break;
          if (value) {
            const text = this.decoder.decode(value);
            try {
              const msg = JSON.parse(text);
              this.notifyHandlers(msg);
            } catch (e) {
              console.error("PyHTML: Error parsing WebTransport message", e);
            }
          }
        }
      } catch (e) {
        console.error("PyHTML: Stream read error", e);
      }
    }
    async send(message) {
      if (!this.transport || !this.connected) {
        console.warn("PyHTML: Cannot send message, WebTransport not connected");
        return;
      }
      try {
        const stream = await this.transport.createBidirectionalStream();
        const writer = stream.writable.getWriter();
        const data = this.encoder.encode(JSON.stringify(message));
        await writer.write(data);
        await writer.close();
        this.handleStream(stream);
      } catch (e) {
        console.error("PyHTML: WebTransport send error", e);
      }
    }
    disconnect() {
      if (this.transport) {
        this.transport.close();
        this.transport = null;
      }
      this.writer = null;
      this.connected = false;
    }
    handleDisconnect() {
      this.connected = false;
      this.transport = null;
      this.writer = null;
    }
  };

  // src/transports/websocket.ts
  var WebSocketTransport = class extends BaseTransport {
    constructor(url) {
      super();
      this.name = "WebSocket";
      this.socket = null;
      this.reconnectAttempts = 0;
      this.maxReconnectDelay = 5e3;
      this.shouldReconnect = true;
      this.url = url || this.getDefaultUrl();
    }
    getDefaultUrl() {
      const protocol = window.location.protocol === "https:" ? "wss:" : "ws:";
      return `${protocol}//${window.location.host}/_pyhtml/ws`;
    }
    connect() {
      return new Promise((resolve, reject) => {
        try {
          this.socket = new WebSocket(this.url);
          this.socket.onopen = () => {
            console.log("PyHTML: WebSocket connected");
            this.connected = true;
            this.reconnectAttempts = 0;
            resolve();
          };
          this.socket.onmessage = (event) => {
            try {
              const msg = JSON.parse(event.data);
              this.notifyHandlers(msg);
            } catch (e) {
              console.error("PyHTML: Error parsing WebSocket message", e);
            }
          };
          this.socket.onclose = () => {
            console.log("PyHTML: WebSocket disconnected");
            this.connected = false;
            if (this.shouldReconnect) {
              this.scheduleReconnect();
            }
          };
          this.socket.onerror = (error) => {
            console.error("PyHTML: WebSocket error", error);
            if (!this.connected) {
              reject(new Error("WebSocket connection failed"));
            }
          };
        } catch (e) {
          reject(e);
        }
      });
    }
    send(message) {
      if (this.socket && this.socket.readyState === WebSocket.OPEN) {
        this.socket.send(JSON.stringify(message));
      } else {
        console.warn("PyHTML: Cannot send message, WebSocket not open");
      }
    }
    disconnect() {
      this.shouldReconnect = false;
      if (this.socket) {
        this.socket.close();
        this.socket = null;
      }
      this.connected = false;
    }
    scheduleReconnect() {
      const delay = Math.min(
        1e3 * Math.pow(2, this.reconnectAttempts),
        this.maxReconnectDelay
      );
      console.log(`PyHTML: Reconnecting in ${delay}ms...`);
      setTimeout(() => {
        this.reconnectAttempts++;
        this.connect().catch(() => {
        });
      }, delay);
    }
  };

  // src/transports/http.ts
  var HTTPTransport = class extends BaseTransport {
    constructor(baseUrl) {
      super();
      this.name = "HTTP";
      this.polling = false;
      this.pollAbortController = null;
      this.sessionId = null;
      this.baseUrl = baseUrl || `${window.location.origin}/_pyhtml`;
    }
    async connect() {
      try {
        const response = await fetch(`${this.baseUrl}/session`, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ path: window.location.pathname + window.location.search })
          // Include query string
        });
        if (!response.ok) {
          throw new Error(`HTTP session init failed: ${response.status}`);
        }
        const data = await response.json();
        this.sessionId = data.sessionId;
        console.log("PyHTML: HTTP transport connected");
        this.connected = true;
        this.startPolling();
      } catch (e) {
        console.error("PyHTML: HTTP transport connection failed", e);
        throw e;
      }
    }
    async startPolling() {
      if (this.polling)
        return;
      this.polling = true;
      while (this.polling && this.connected) {
        try {
          this.pollAbortController = new AbortController();
          const response = await fetch(`${this.baseUrl}/poll?session=${this.sessionId}`, {
            method: "GET",
            signal: this.pollAbortController.signal,
            headers: {
              "Accept": "application/json"
            }
          });
          if (!response.ok) {
            if (response.status === 404) {
              console.warn("PyHTML: HTTP session expired, reconnecting...");
              this.connected = false;
              await this.connect();
              return;
            }
            throw new Error(`Poll failed: ${response.status}`);
          }
          const messages = await response.json();
          for (const msg of messages) {
            this.notifyHandlers(msg);
          }
        } catch (e) {
          if (e instanceof Error && e.name === "AbortError") {
            break;
          }
          console.error("PyHTML: HTTP poll error", e);
          await this.sleep(1e3);
        }
      }
    }
    async send(message) {
      if (!this.connected || !this.sessionId) {
        console.warn("PyHTML: Cannot send message, HTTP transport not connected");
        return;
      }
      try {
        const response = await fetch(`${this.baseUrl}/event`, {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            "X-PyHTML-Session": this.sessionId
          },
          body: JSON.stringify(message)
        });
        if (!response.ok) {
          throw new Error(`Event send failed: ${response.status}`);
        }
        const result = await response.json();
        this.notifyHandlers(result);
      } catch (e) {
        console.error("PyHTML: HTTP send error", e);
      }
    }
    disconnect() {
      this.polling = false;
      this.connected = false;
      if (this.pollAbortController) {
        this.pollAbortController.abort();
        this.pollAbortController = null;
      }
      this.sessionId = null;
    }
    sleep(ms) {
      return new Promise((resolve) => setTimeout(resolve, ms));
    }
  };

  // src/transport-manager.ts
  var DEFAULT_CONFIG = {
    enableWebTransport: true,
    enableWebSocket: true,
    enableHTTP: true
  };
  var TransportManager = class {
    constructor(config = {}) {
      this.transport = null;
      this.messageHandlers = [];
      this.config = { ...DEFAULT_CONFIG, ...config };
    }
    /**
     * Connect using the best available transport with fallback.
     */
    async connect() {
      const transports = this.getTransportPriority();
      for (const TransportClass of transports) {
        try {
          console.log(`PyHTML: Trying ${TransportClass.name}...`);
          this.transport = new TransportClass();
          for (const handler of this.messageHandlers) {
            this.transport.onMessage(handler);
          }
          await this.transport.connect();
          console.log(`PyHTML: Connected via ${this.transport.name}`);
          return;
        } catch (e) {
          console.warn(`PyHTML: ${TransportClass.name} failed, trying next...`, e);
          this.transport = null;
        }
      }
      throw new Error("PyHTML: All transports failed");
    }
    /**
     * Get transport classes in priority order based on config and browser support.
     */
    getTransportPriority() {
      const transports = [];
      if (this.config.enableWebTransport && WebTransportTransport.isSupported()) {
        if (window.location.protocol === "https:") {
          transports.push(WebTransportTransport);
        }
      }
      if (this.config.enableWebSocket && typeof WebSocket !== "undefined") {
        transports.push(WebSocketTransport);
      }
      if (this.config.enableHTTP) {
        transports.push(HTTPTransport);
      }
      return transports;
    }
    /**
     * Send a message through the active transport.
     */
    send(message) {
      if (this.transport) {
        this.transport.send(message);
      } else {
        console.warn("PyHTML: No active transport");
      }
    }
    /**
     * Register a message handler.
     */
    onMessage(handler) {
      this.messageHandlers.push(handler);
      if (this.transport) {
        this.transport.onMessage(handler);
      }
    }
    /**
     * Disconnect the active transport.
     */
    disconnect() {
      if (this.transport) {
        this.transport.disconnect();
        this.transport = null;
      }
    }
    /**
     * Get the name of the active transport.
     */
    getActiveTransport() {
      return this.transport?.name || null;
    }
    /**
     * Check if connected.
     */
    isConnected() {
      return this.transport?.isConnected() || false;
    }
  };

  // node_modules/morphdom/dist/morphdom-esm.js
  var DOCUMENT_FRAGMENT_NODE = 11;
  function morphAttrs(fromNode, toNode) {
    var toNodeAttrs = toNode.attributes;
    var attr;
    var attrName;
    var attrNamespaceURI;
    var attrValue;
    var fromValue;
    if (toNode.nodeType === DOCUMENT_FRAGMENT_NODE || fromNode.nodeType === DOCUMENT_FRAGMENT_NODE) {
      return;
    }
    for (var i = toNodeAttrs.length - 1; i >= 0; i--) {
      attr = toNodeAttrs[i];
      attrName = attr.name;
      attrNamespaceURI = attr.namespaceURI;
      attrValue = attr.value;
      if (attrNamespaceURI) {
        attrName = attr.localName || attrName;
        fromValue = fromNode.getAttributeNS(attrNamespaceURI, attrName);
        if (fromValue !== attrValue) {
          if (attr.prefix === "xmlns") {
            attrName = attr.name;
          }
          fromNode.setAttributeNS(attrNamespaceURI, attrName, attrValue);
        }
      } else {
        fromValue = fromNode.getAttribute(attrName);
        if (fromValue !== attrValue) {
          fromNode.setAttribute(attrName, attrValue);
        }
      }
    }
    var fromNodeAttrs = fromNode.attributes;
    for (var d = fromNodeAttrs.length - 1; d >= 0; d--) {
      attr = fromNodeAttrs[d];
      attrName = attr.name;
      attrNamespaceURI = attr.namespaceURI;
      if (attrNamespaceURI) {
        attrName = attr.localName || attrName;
        if (!toNode.hasAttributeNS(attrNamespaceURI, attrName)) {
          fromNode.removeAttributeNS(attrNamespaceURI, attrName);
        }
      } else {
        if (!toNode.hasAttribute(attrName)) {
          fromNode.removeAttribute(attrName);
        }
      }
    }
  }
  var range;
  var NS_XHTML = "http://www.w3.org/1999/xhtml";
  var doc = typeof document === "undefined" ? void 0 : document;
  var HAS_TEMPLATE_SUPPORT = !!doc && "content" in doc.createElement("template");
  var HAS_RANGE_SUPPORT = !!doc && doc.createRange && "createContextualFragment" in doc.createRange();
  function createFragmentFromTemplate(str) {
    var template = doc.createElement("template");
    template.innerHTML = str;
    return template.content.childNodes[0];
  }
  function createFragmentFromRange(str) {
    if (!range) {
      range = doc.createRange();
      range.selectNode(doc.body);
    }
    var fragment = range.createContextualFragment(str);
    return fragment.childNodes[0];
  }
  function createFragmentFromWrap(str) {
    var fragment = doc.createElement("body");
    fragment.innerHTML = str;
    return fragment.childNodes[0];
  }
  function toElement(str) {
    str = str.trim();
    if (HAS_TEMPLATE_SUPPORT) {
      return createFragmentFromTemplate(str);
    } else if (HAS_RANGE_SUPPORT) {
      return createFragmentFromRange(str);
    }
    return createFragmentFromWrap(str);
  }
  function compareNodeNames(fromEl, toEl) {
    var fromNodeName = fromEl.nodeName;
    var toNodeName = toEl.nodeName;
    var fromCodeStart, toCodeStart;
    if (fromNodeName === toNodeName) {
      return true;
    }
    fromCodeStart = fromNodeName.charCodeAt(0);
    toCodeStart = toNodeName.charCodeAt(0);
    if (fromCodeStart <= 90 && toCodeStart >= 97) {
      return fromNodeName === toNodeName.toUpperCase();
    } else if (toCodeStart <= 90 && fromCodeStart >= 97) {
      return toNodeName === fromNodeName.toUpperCase();
    } else {
      return false;
    }
  }
  function createElementNS(name, namespaceURI) {
    return !namespaceURI || namespaceURI === NS_XHTML ? doc.createElement(name) : doc.createElementNS(namespaceURI, name);
  }
  function moveChildren(fromEl, toEl) {
    var curChild = fromEl.firstChild;
    while (curChild) {
      var nextChild = curChild.nextSibling;
      toEl.appendChild(curChild);
      curChild = nextChild;
    }
    return toEl;
  }
  function syncBooleanAttrProp(fromEl, toEl, name) {
    if (fromEl[name] !== toEl[name]) {
      fromEl[name] = toEl[name];
      if (fromEl[name]) {
        fromEl.setAttribute(name, "");
      } else {
        fromEl.removeAttribute(name);
      }
    }
  }
  var specialElHandlers = {
    OPTION: function(fromEl, toEl) {
      var parentNode = fromEl.parentNode;
      if (parentNode) {
        var parentName = parentNode.nodeName.toUpperCase();
        if (parentName === "OPTGROUP") {
          parentNode = parentNode.parentNode;
          parentName = parentNode && parentNode.nodeName.toUpperCase();
        }
        if (parentName === "SELECT" && !parentNode.hasAttribute("multiple")) {
          if (fromEl.hasAttribute("selected") && !toEl.selected) {
            fromEl.setAttribute("selected", "selected");
            fromEl.removeAttribute("selected");
          }
          parentNode.selectedIndex = -1;
        }
      }
      syncBooleanAttrProp(fromEl, toEl, "selected");
    },
    /**
     * The "value" attribute is special for the <input> element since it sets
     * the initial value. Changing the "value" attribute without changing the
     * "value" property will have no effect since it is only used to the set the
     * initial value.  Similar for the "checked" attribute, and "disabled".
     */
    INPUT: function(fromEl, toEl) {
      syncBooleanAttrProp(fromEl, toEl, "checked");
      syncBooleanAttrProp(fromEl, toEl, "disabled");
      if (fromEl.value !== toEl.value) {
        fromEl.value = toEl.value;
      }
      if (!toEl.hasAttribute("value")) {
        fromEl.removeAttribute("value");
      }
    },
    TEXTAREA: function(fromEl, toEl) {
      var newValue = toEl.value;
      if (fromEl.value !== newValue) {
        fromEl.value = newValue;
      }
      var firstChild = fromEl.firstChild;
      if (firstChild) {
        var oldValue = firstChild.nodeValue;
        if (oldValue == newValue || !newValue && oldValue == fromEl.placeholder) {
          return;
        }
        firstChild.nodeValue = newValue;
      }
    },
    SELECT: function(fromEl, toEl) {
      if (!toEl.hasAttribute("multiple")) {
        var selectedIndex = -1;
        var i = 0;
        var curChild = fromEl.firstChild;
        var optgroup;
        var nodeName;
        while (curChild) {
          nodeName = curChild.nodeName && curChild.nodeName.toUpperCase();
          if (nodeName === "OPTGROUP") {
            optgroup = curChild;
            curChild = optgroup.firstChild;
            if (!curChild) {
              curChild = optgroup.nextSibling;
              optgroup = null;
            }
          } else {
            if (nodeName === "OPTION") {
              if (curChild.hasAttribute("selected")) {
                selectedIndex = i;
                break;
              }
              i++;
            }
            curChild = curChild.nextSibling;
            if (!curChild && optgroup) {
              curChild = optgroup.nextSibling;
              optgroup = null;
            }
          }
        }
        fromEl.selectedIndex = selectedIndex;
      }
    }
  };
  var ELEMENT_NODE = 1;
  var DOCUMENT_FRAGMENT_NODE$1 = 11;
  var TEXT_NODE = 3;
  var COMMENT_NODE = 8;
  function noop() {
  }
  function defaultGetNodeKey(node) {
    if (node) {
      return node.getAttribute && node.getAttribute("id") || node.id;
    }
  }
  function morphdomFactory(morphAttrs2) {
    return function morphdom2(fromNode, toNode, options) {
      if (!options) {
        options = {};
      }
      if (typeof toNode === "string") {
        if (fromNode.nodeName === "#document" || fromNode.nodeName === "HTML" || fromNode.nodeName === "BODY") {
          var toNodeHtml = toNode;
          toNode = doc.createElement("html");
          toNode.innerHTML = toNodeHtml;
        } else {
          toNode = toElement(toNode);
        }
      } else if (toNode.nodeType === DOCUMENT_FRAGMENT_NODE$1) {
        toNode = toNode.firstElementChild;
      }
      var getNodeKey = options.getNodeKey || defaultGetNodeKey;
      var onBeforeNodeAdded = options.onBeforeNodeAdded || noop;
      var onNodeAdded = options.onNodeAdded || noop;
      var onBeforeElUpdated = options.onBeforeElUpdated || noop;
      var onElUpdated = options.onElUpdated || noop;
      var onBeforeNodeDiscarded = options.onBeforeNodeDiscarded || noop;
      var onNodeDiscarded = options.onNodeDiscarded || noop;
      var onBeforeElChildrenUpdated = options.onBeforeElChildrenUpdated || noop;
      var skipFromChildren = options.skipFromChildren || noop;
      var addChild = options.addChild || function(parent, child) {
        return parent.appendChild(child);
      };
      var childrenOnly = options.childrenOnly === true;
      var fromNodesLookup = /* @__PURE__ */ Object.create(null);
      var keyedRemovalList = [];
      function addKeyedRemoval(key) {
        keyedRemovalList.push(key);
      }
      function walkDiscardedChildNodes(node, skipKeyedNodes) {
        if (node.nodeType === ELEMENT_NODE) {
          var curChild = node.firstChild;
          while (curChild) {
            var key = void 0;
            if (skipKeyedNodes && (key = getNodeKey(curChild))) {
              addKeyedRemoval(key);
            } else {
              onNodeDiscarded(curChild);
              if (curChild.firstChild) {
                walkDiscardedChildNodes(curChild, skipKeyedNodes);
              }
            }
            curChild = curChild.nextSibling;
          }
        }
      }
      function removeNode(node, parentNode, skipKeyedNodes) {
        if (onBeforeNodeDiscarded(node) === false) {
          return;
        }
        if (parentNode) {
          parentNode.removeChild(node);
        }
        onNodeDiscarded(node);
        walkDiscardedChildNodes(node, skipKeyedNodes);
      }
      function indexTree(node) {
        if (node.nodeType === ELEMENT_NODE || node.nodeType === DOCUMENT_FRAGMENT_NODE$1) {
          var curChild = node.firstChild;
          while (curChild) {
            var key = getNodeKey(curChild);
            if (key) {
              fromNodesLookup[key] = curChild;
            }
            indexTree(curChild);
            curChild = curChild.nextSibling;
          }
        }
      }
      indexTree(fromNode);
      function handleNodeAdded(el) {
        onNodeAdded(el);
        var curChild = el.firstChild;
        while (curChild) {
          var nextSibling = curChild.nextSibling;
          var key = getNodeKey(curChild);
          if (key) {
            var unmatchedFromEl = fromNodesLookup[key];
            if (unmatchedFromEl && compareNodeNames(curChild, unmatchedFromEl)) {
              curChild.parentNode.replaceChild(unmatchedFromEl, curChild);
              morphEl(unmatchedFromEl, curChild);
            } else {
              handleNodeAdded(curChild);
            }
          } else {
            handleNodeAdded(curChild);
          }
          curChild = nextSibling;
        }
      }
      function cleanupFromEl(fromEl, curFromNodeChild, curFromNodeKey) {
        while (curFromNodeChild) {
          var fromNextSibling = curFromNodeChild.nextSibling;
          if (curFromNodeKey = getNodeKey(curFromNodeChild)) {
            addKeyedRemoval(curFromNodeKey);
          } else {
            removeNode(
              curFromNodeChild,
              fromEl,
              true
              /* skip keyed nodes */
            );
          }
          curFromNodeChild = fromNextSibling;
        }
      }
      function morphEl(fromEl, toEl, childrenOnly2) {
        var toElKey = getNodeKey(toEl);
        if (toElKey) {
          delete fromNodesLookup[toElKey];
        }
        if (!childrenOnly2) {
          var beforeUpdateResult = onBeforeElUpdated(fromEl, toEl);
          if (beforeUpdateResult === false) {
            return;
          } else if (beforeUpdateResult instanceof HTMLElement) {
            fromEl = beforeUpdateResult;
            indexTree(fromEl);
          }
          morphAttrs2(fromEl, toEl);
          onElUpdated(fromEl);
          if (onBeforeElChildrenUpdated(fromEl, toEl) === false) {
            return;
          }
        }
        if (fromEl.nodeName !== "TEXTAREA") {
          morphChildren(fromEl, toEl);
        } else {
          specialElHandlers.TEXTAREA(fromEl, toEl);
        }
      }
      function morphChildren(fromEl, toEl) {
        var skipFrom = skipFromChildren(fromEl, toEl);
        var curToNodeChild = toEl.firstChild;
        var curFromNodeChild = fromEl.firstChild;
        var curToNodeKey;
        var curFromNodeKey;
        var fromNextSibling;
        var toNextSibling;
        var matchingFromEl;
        outer:
          while (curToNodeChild) {
            toNextSibling = curToNodeChild.nextSibling;
            curToNodeKey = getNodeKey(curToNodeChild);
            while (!skipFrom && curFromNodeChild) {
              fromNextSibling = curFromNodeChild.nextSibling;
              if (curToNodeChild.isSameNode && curToNodeChild.isSameNode(curFromNodeChild)) {
                curToNodeChild = toNextSibling;
                curFromNodeChild = fromNextSibling;
                continue outer;
              }
              curFromNodeKey = getNodeKey(curFromNodeChild);
              var curFromNodeType = curFromNodeChild.nodeType;
              var isCompatible = void 0;
              if (curFromNodeType === curToNodeChild.nodeType) {
                if (curFromNodeType === ELEMENT_NODE) {
                  if (curToNodeKey) {
                    if (curToNodeKey !== curFromNodeKey) {
                      if (matchingFromEl = fromNodesLookup[curToNodeKey]) {
                        if (fromNextSibling === matchingFromEl) {
                          isCompatible = false;
                        } else {
                          fromEl.insertBefore(matchingFromEl, curFromNodeChild);
                          if (curFromNodeKey) {
                            addKeyedRemoval(curFromNodeKey);
                          } else {
                            removeNode(
                              curFromNodeChild,
                              fromEl,
                              true
                              /* skip keyed nodes */
                            );
                          }
                          curFromNodeChild = matchingFromEl;
                          curFromNodeKey = getNodeKey(curFromNodeChild);
                        }
                      } else {
                        isCompatible = false;
                      }
                    }
                  } else if (curFromNodeKey) {
                    isCompatible = false;
                  }
                  isCompatible = isCompatible !== false && compareNodeNames(curFromNodeChild, curToNodeChild);
                  if (isCompatible) {
                    morphEl(curFromNodeChild, curToNodeChild);
                  }
                } else if (curFromNodeType === TEXT_NODE || curFromNodeType == COMMENT_NODE) {
                  isCompatible = true;
                  if (curFromNodeChild.nodeValue !== curToNodeChild.nodeValue) {
                    curFromNodeChild.nodeValue = curToNodeChild.nodeValue;
                  }
                }
              }
              if (isCompatible) {
                curToNodeChild = toNextSibling;
                curFromNodeChild = fromNextSibling;
                continue outer;
              }
              if (curFromNodeKey) {
                addKeyedRemoval(curFromNodeKey);
              } else {
                removeNode(
                  curFromNodeChild,
                  fromEl,
                  true
                  /* skip keyed nodes */
                );
              }
              curFromNodeChild = fromNextSibling;
            }
            if (curToNodeKey && (matchingFromEl = fromNodesLookup[curToNodeKey]) && compareNodeNames(matchingFromEl, curToNodeChild)) {
              if (!skipFrom) {
                addChild(fromEl, matchingFromEl);
              }
              morphEl(matchingFromEl, curToNodeChild);
            } else {
              var onBeforeNodeAddedResult = onBeforeNodeAdded(curToNodeChild);
              if (onBeforeNodeAddedResult !== false) {
                if (onBeforeNodeAddedResult) {
                  curToNodeChild = onBeforeNodeAddedResult;
                }
                if (curToNodeChild.actualize) {
                  curToNodeChild = curToNodeChild.actualize(fromEl.ownerDocument || doc);
                }
                addChild(fromEl, curToNodeChild);
                handleNodeAdded(curToNodeChild);
              }
            }
            curToNodeChild = toNextSibling;
            curFromNodeChild = fromNextSibling;
          }
        cleanupFromEl(fromEl, curFromNodeChild, curFromNodeKey);
        var specialElHandler = specialElHandlers[fromEl.nodeName];
        if (specialElHandler) {
          specialElHandler(fromEl, toEl);
        }
      }
      var morphedNode = fromNode;
      var morphedNodeType = morphedNode.nodeType;
      var toNodeType = toNode.nodeType;
      if (!childrenOnly) {
        if (morphedNodeType === ELEMENT_NODE) {
          if (toNodeType === ELEMENT_NODE) {
            if (!compareNodeNames(fromNode, toNode)) {
              onNodeDiscarded(fromNode);
              morphedNode = moveChildren(fromNode, createElementNS(toNode.nodeName, toNode.namespaceURI));
            }
          } else {
            morphedNode = toNode;
          }
        } else if (morphedNodeType === TEXT_NODE || morphedNodeType === COMMENT_NODE) {
          if (toNodeType === morphedNodeType) {
            if (morphedNode.nodeValue !== toNode.nodeValue) {
              morphedNode.nodeValue = toNode.nodeValue;
            }
            return morphedNode;
          } else {
            morphedNode = toNode;
          }
        }
      }
      if (morphedNode === toNode) {
        onNodeDiscarded(fromNode);
      } else {
        if (toNode.isSameNode && toNode.isSameNode(morphedNode)) {
          return;
        }
        morphEl(morphedNode, toNode, childrenOnly);
        if (keyedRemovalList) {
          for (var i = 0, len = keyedRemovalList.length; i < len; i++) {
            var elToRemove = fromNodesLookup[keyedRemovalList[i]];
            if (elToRemove) {
              removeNode(elToRemove, elToRemove.parentNode, false);
            }
          }
        }
      }
      if (!childrenOnly && morphedNode !== fromNode && fromNode.parentNode) {
        if (morphedNode.actualize) {
          morphedNode = morphedNode.actualize(fromNode.ownerDocument || doc);
        }
        fromNode.parentNode.replaceChild(morphedNode, fromNode);
      }
      return morphedNode;
    };
  }
  var morphdom = morphdomFactory(morphAttrs);
  var morphdom_esm_default = morphdom;

  // src/dom-updater.ts
  var DOMUpdater = class {
    /**
     * Update the DOM with new HTML content.
     */
    update(newHtml) {
      if (morphdom_esm_default) {
        morphdom_esm_default(document.documentElement, newHtml);
      } else {
        document.open();
        document.write(newHtml);
        document.close();
      }
    }
  };

  // src/index.ts
  var DEFAULT_CONFIG2 = {
    autoInit: true,
    enableWebTransport: true,
    enableWebSocket: true,
    enableHTTP: true
  };
  var PyHTMLApp = class {
    constructor(config = {}) {
      this.initialized = false;
      this.siblingPaths = [];
      this.pathRegexes = [];
      this.config = { ...DEFAULT_CONFIG2, ...config };
      this.transport = new TransportManager(this.config);
      this.updater = new DOMUpdater();
    }
    /**
     * Initialize the PyHTML application.
     */
    async init() {
      if (this.initialized)
        return;
      this.initialized = true;
      this.transport.onMessage((msg) => this.handleMessage(msg));
      try {
        await this.transport.connect();
      } catch (e) {
        console.error("PyHTML: Failed to connect:", e);
      }
      this.loadSPAMetadata();
      this.setupSPANavigation();
      this.setupEventInterceptors();
      console.log(`PyHTML: Initialized (transport: ${this.transport.getActiveTransport()}, spa_paths: ${this.siblingPaths.length})`);
    }
    /**
     * Load SPA navigation metadata from injected script tag.
     */
    loadSPAMetadata() {
      const metaScript = document.getElementById("_pyhtml_spa_meta");
      if (metaScript) {
        try {
          const meta = JSON.parse(metaScript.textContent || "{}");
          this.siblingPaths = meta.sibling_paths || [];
          this.pathRegexes = this.siblingPaths.map((p) => this.patternToRegex(p));
        } catch (e) {
          console.warn("PyHTML: Failed to parse SPA metadata", e);
        }
      }
    }
    /**
     * Convert route pattern like '/a/:id' to regex.
     */
    patternToRegex(pattern) {
      let regex = pattern.replace(/[.+?^${}()|[\]\\]/g, "\\$&");
      regex = regex.replace(/:(\w+)(:\w+)?/g, "([^/]+)");
      regex = regex.replace(/\{(\w+)(:\w+)?\}/g, "([^/]+)");
      return new RegExp(`^${regex}$`);
    }
    /**
     * Check if a path matches any sibling path pattern.
     */
    isSiblingPath(path) {
      return this.pathRegexes.some((regex) => regex.test(path));
    }
    /**
     * Setup SPA navigation for sibling paths.
     */
    setupSPANavigation() {
      if (this.siblingPaths.length === 0)
        return;
      document.addEventListener("click", (e) => {
        const link = e.target.closest("a[href]");
        if (!link)
          return;
        if (link.origin !== window.location.origin)
          return;
        if (this.isSiblingPath(link.pathname)) {
          e.preventDefault();
          this.navigateTo(link.pathname + link.search);
        }
      });
      window.addEventListener("popstate", () => {
        this.sendRelocate(window.location.pathname + window.location.search);
      });
    }
    /**
     * Navigate to a sibling path using SPA navigation.
     */
    navigateTo(path) {
      history.pushState({}, "", path);
      this.sendRelocate(path);
    }
    /**
     * Send relocate message to server.
     */
    sendRelocate(path) {
      const message = {
        type: "relocate",
        path
      };
      this.transport.send(message);
    }
    /**
     * Setup DOM event interceptors.
     */
    setupEventInterceptors() {
      document.addEventListener("click", (e) => {
        const target = e.target.closest("[data-on-click]");
        if (target) {
          e.preventDefault();
          const handler = target.getAttribute("data-on-click");
          if (handler) {
            this.sendEvent(handler, {
              type: "click",
              id: target.id,
              value: target.value,
              args: this.getArgs(target)
            });
          }
        }
      });
      document.addEventListener("submit", (e) => {
        const target = e.target.closest("[data-on-submit]");
        if (target) {
          e.preventDefault();
          const handler = target.getAttribute("data-on-submit");
          if (handler) {
            const formData = new FormData(target);
            const data = {};
            formData.forEach((value, key) => {
              data[key] = value.toString();
            });
            this.sendEvent(handler, {
              type: "submit",
              id: target.id,
              formData: data,
              args: this.getArgs(target)
            });
          }
        }
      });
      let inputTimeout;
      document.addEventListener("input", (e) => {
        const target = e.target.closest("[data-on-input]");
        if (target) {
          clearTimeout(inputTimeout);
          inputTimeout = window.setTimeout(() => {
            const handler = target.getAttribute("data-on-input");
            if (handler) {
              this.sendEvent(handler, {
                type: "input",
                id: target.id,
                value: target.value,
                args: this.getArgs(target)
              });
            }
          }, 150);
        }
      });
      document.addEventListener("change", (e) => {
        const target = e.target.closest("[data-on-change]");
        if (target) {
          const handler = target.getAttribute("data-on-change");
          if (handler) {
            this.sendEvent(handler, {
              type: "change",
              id: target.id,
              value: target.value,
              checked: target.checked,
              args: this.getArgs(target)
            });
          }
        }
      });
    }
    /**
     * Collect data-arg-* attributes from element.
     */
    getArgs(element) {
      const args = {};
      if (element instanceof HTMLElement) {
        for (const key in element.dataset) {
          if (key.startsWith("arg")) {
            try {
              args[key] = JSON.parse(element.dataset[key] || "null");
            } catch (e) {
              console.warn("PyHTML: Failed to parse arg", key, element.dataset[key]);
              args[key] = element.dataset[key];
            }
          }
        }
      }
      return args;
    }
    /**
     * Send an event to the server.
     */
    sendEvent(handler, data) {
      const message = {
        type: "event",
        handler,
        path: window.location.pathname + window.location.search,
        data
      };
      this.transport.send(message);
    }
    /**
     * Handle incoming server message.
     */
    handleMessage(msg) {
      switch (msg.type) {
        case "update":
          if (msg.html) {
            this.updater.update(msg.html);
          }
          break;
        case "reload":
          console.log("PyHTML: Reloading...");
          window.location.reload();
          break;
        case "error":
          console.error("PyHTML: Server error:", msg.error);
          break;
        case "console":
          if (msg.lines) {
            const prefix = "PyHTML Server:";
            const lines = msg.lines;
            if (msg.level === "error") {
              console.error(prefix, ...lines);
            } else if (msg.level === "warn") {
              console.warn(prefix, ...lines);
            } else {
              console.log(prefix, ...lines);
            }
          }
          break;
        default:
          console.warn("PyHTML: Unknown message type", msg);
      }
    }
    /**
     * Get the current transport name.
     */
    getTransport() {
      return this.transport.getActiveTransport();
    }
    /**
     * Disconnect from the server.
     */
    disconnect() {
      this.transport.disconnect();
    }
  };
  var app = new PyHTMLApp();
  if (document.readyState === "loading") {
    document.addEventListener("DOMContentLoaded", () => app.init());
  } else {
    app.init();
  }
  return __toCommonJS(src_exports);
})();
//# sourceMappingURL=pyhtml.min.js.map
